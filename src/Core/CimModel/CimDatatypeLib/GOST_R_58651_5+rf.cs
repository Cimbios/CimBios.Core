using CimBios.Core.CimModel.CimDatatypeLib;
/**
 * Annotated C# for Profile
 * Generated by CIMTool http://cimtool.org
 */
namespace Profile
{
    /// <summary>
    /// Records activity for an entity at a point in time; activity may be for
    /// an event that has already occurred or for a planned activity.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ActivityRecord")]
    public partial class ActivityRecord : IdentifiedObject, IModelObject
    {
        public ActivityRecord(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date and time this activity record has been created (different from the
        /// 'status.dateTime', which is the time of a status change of the associated
        /// object, if applicable).
        /// </summary>
        public object createdDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(createdDateTime));
            set => ObjectData.SetAttribute<object>(nameof(createdDateTime), value);
        }
         
        /// <summary>
        /// Reason for event resulting in this activity record, typically supplied
        /// when user initiated.
        /// </summary>
        public string reason
        {
            get => ObjectData.GetAttribute<string>(nameof(reason));
            set => ObjectData.SetAttribute<string>(nameof(reason), value);
        }
         
        /// <summary>
        /// Severity level of event resulting in this activity record.
        /// </summary>
        public string severity
        {
            get => ObjectData.GetAttribute<string>(nameof(severity));
            set => ObjectData.SetAttribute<string>(nameof(severity), value);
        }
         
        /// <summary>
        /// Type of event resulting in this activity record.
        /// </summary>
        public string type
        {
            get => ObjectData.GetAttribute<string>(nameof(type));
            set => ObjectData.SetAttribute<string>(nameof(type), value);
        }
         
        /// <summary>
        /// All assets for which this activity record has been created.
        /// </summary>
        public Asset[]? Assets
        {
            get => ObjectData.GetAssoc1ToM<Asset>(nameof(Assets));
        }
         
        public void AddToAssets(Asset value)
        {
            ObjectData.AddAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveFromAssets(Asset value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveAllFromAssets()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Assets));
        }
         
        /// <summary>
        /// Information on consequence of event resulting in this activity record.
        /// </summary>
        public Status status
        {
            get => ObjectData.GetAttribute<Status>(nameof(status));
            set => ObjectData.SetAttribute<Status>(nameof(status), value);
        }
         
    }
     
    /// <summary>
    /// Formal agreement between two parties defining the terms and conditions
    /// for a set of services. The specifics of the services are, in turn, defined
    /// via one or more service agreements.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Agreement")]
    public partial class Agreement : Document, IModelObject
    {
        public Agreement(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date this agreement was consummated among associated persons and/or organisations.
        /// </summary>
        public DateOnly signDate
        {
            get => ObjectData.GetAttribute<DateOnly>(nameof(signDate));
            set => ObjectData.SetAttribute<DateOnly>(nameof(signDate), value);
        }
         
        /// <summary>
        /// Date and time interval this agreement is valid (from going into effect
        /// to termination).
        /// </summary>
        public DateTimeInterval validityInterval
        {
            get => ObjectData.GetAttribute<DateTimeInterval>(nameof(validityInterval));
            set => ObjectData.SetAttribute<DateTimeInterval>(nameof(validityInterval), value);
        }
         
    }
     
    /// <summary>
    /// Lifecycle states of the metering installation at a usage point with respect
    /// to readiness for billing via advanced metering infrastructure reads.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AmiBillingReadyKind")]
    public enum AmiBillingReadyKind
    {
        /// <summary>
        /// Usage point is equipped with an AMI capable meter that is not yet currently
        /// equipped with a communications module.
        /// </summary>
        amiCapable,
        /// <summary>
        /// Usage point is equipped with an AMI capable meter; however, the AMI functionality
        /// has been disabled or is not being used.
        /// </summary>
        amiDisabled,
        /// <summary>
        /// Usage point is equipped with an operating AMI capable meter and accuracy
        /// has been certified for billing purposes.
        /// </summary>
        billingApproved,
        /// <summary>
        /// Usage point is equipped with an AMI capable meter having communications
        /// capability.
        /// </summary>
        enabled,
        /// <summary>
        /// Usage point is equipped with a non AMI capable meter.
        /// </summary>
        nonAmi,
        /// <summary>
        /// Usage point is not currently equipped with a meter.
        /// </summary>
        nonMetered,
        /// <summary>
        /// Usage point is equipped with an AMI capable meter that is functioning and
        /// communicating with the AMI network.
        /// </summary>
        operable,
    }
     
    /// <summary>
    /// Tangible resource of the utility, including power system equipment, various
    /// end devices, cabinets, buildings, etc. For electrical network equipment,
    /// the role of the asset is defined through PowerSystemResource and its subclasses,
    /// defined mainly in the Wires model (refer to IEC61970-301 and model package
    /// IEC61970::Wires). Asset description places emphasis on the physical characteristics
    /// of the equipment fulfilling that role.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Asset")]
    public partial class Asset : IdentifiedObject, IModelObject
    {
        public Asset(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public string baselineCondition
        {
            get => ObjectData.GetAttribute<string>(nameof(baselineCondition));
            set => ObjectData.SetAttribute<string>(nameof(baselineCondition), value);
        }
         
        /// <summary>
        /// </summary>
        public float baselineLossOfLife
        {
            get => ObjectData.GetAttribute<float>(nameof(baselineLossOfLife));
            set => ObjectData.SetAttribute<float>(nameof(baselineLossOfLife), value);
        }
         
        /// <summary>
        /// Lot number for this asset. Even for the same model and version number,
        /// many assets are manufactured in lots.
        /// </summary>
        public string lotNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(lotNumber));
            set => ObjectData.SetAttribute<string>(nameof(lotNumber), value);
        }
         
        /// <summary>
        /// Serial number of this asset.
        /// </summary>
        public string serialNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(serialNumber));
            set => ObjectData.SetAttribute<string>(nameof(serialNumber), value);
        }
         
        /// <summary>
        /// Uniquely tracked commodity (UTC) number.
        /// </summary>
        public string utcNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(utcNumber));
            set => ObjectData.SetAttribute<string>(nameof(utcNumber), value);
        }
         
        /// <summary>
        /// All activity records created for this asset.
        /// </summary>
        public ActivityRecord[]? ActivityRecords
        {
            get => ObjectData.GetAssoc1ToM<ActivityRecord>(nameof(ActivityRecords));
        }
         
        public void AddToActivityRecords(ActivityRecord value)
        {
            ObjectData.AddAssoc1ToM(nameof(ActivityRecords), value);
        }
         
        public void RemoveFromActivityRecords(ActivityRecord value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ActivityRecords), value);
        }
         
        public void RemoveAllFromActivityRecords()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ActivityRecords));
        }
         
        /// <summary>
        /// All configuration events created for this asset.
        /// </summary>
        public ConfigurationEvent[]? ConfigurationEvents
        {
            get => ObjectData.GetAssoc1ToM<ConfigurationEvent>(nameof(ConfigurationEvents));
        }
         
        public void AddToConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveFromConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveAllFromConfigurationEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConfigurationEvents));
        }
         
        /// <summary>
        /// Electronic address.
        /// </summary>
        public ElectronicAddress electronicAddress
        {
            get => ObjectData.GetAttribute<ElectronicAddress>(nameof(electronicAddress));
            set => ObjectData.SetAttribute<ElectronicAddress>(nameof(electronicAddress), value);
        }
         
        /// <summary>
        /// Status of this asset.
        /// </summary>
        public Status status
        {
            get => ObjectData.GetAttribute<Status>(nameof(status));
            set => ObjectData.SetAttribute<Status>(nameof(status), value);
        }
         
    }
     
    /// <summary>
    /// Asset that is aggregation of other assets such as conductors, transformers,
    /// switchgear, land, fences, buildings, equipment, vehicles, etc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AssetContainer")]
    public partial class AssetContainer : Asset, IModelObject
    {
        public AssetContainer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All seals applied to this asset container.
        /// </summary>
        public Seal[]? Seals
        {
            get => ObjectData.GetAssoc1ToM<Seal>(nameof(Seals));
        }
         
        public void AddToSeals(Seal value)
        {
            ObjectData.AddAssoc1ToM(nameof(Seals), value);
        }
         
        public void RemoveFromSeals(Seal value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Seals), value);
        }
         
        public void RemoveAllFromSeals()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Seals));
        }
         
    }
     
    /// <summary>
    /// Function performed by an asset.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AssetFunction")]
    public partial class AssetFunction : IdentifiedObject, IModelObject
    {
        public AssetFunction(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Configuration specified for this function.
        /// </summary>
        public string configID
        {
            get => ObjectData.GetAttribute<string>(nameof(configID));
            set => ObjectData.SetAttribute<string>(nameof(configID), value);
        }
         
        /// <summary>
        /// Firmware version.
        /// </summary>
        public string firmwareID
        {
            get => ObjectData.GetAttribute<string>(nameof(firmwareID));
            set => ObjectData.SetAttribute<string>(nameof(firmwareID), value);
        }
         
        /// <summary>
        /// Hardware version.
        /// </summary>
        public string hardwareID
        {
            get => ObjectData.GetAttribute<string>(nameof(hardwareID));
            set => ObjectData.SetAttribute<string>(nameof(hardwareID), value);
        }
         
        /// <summary>
        /// Password needed to access this function.
        /// </summary>
        public string password
        {
            get => ObjectData.GetAttribute<string>(nameof(password));
            set => ObjectData.SetAttribute<string>(nameof(password), value);
        }
         
        /// <summary>
        /// Name of program.
        /// </summary>
        public string programID
        {
            get => ObjectData.GetAttribute<string>(nameof(programID));
            set => ObjectData.SetAttribute<string>(nameof(programID), value);
        }
         
    }
     
    /// <summary>
    /// Usage for an asset model.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AssetModelUsageKind")]
    public enum AssetModelUsageKind
    {
        /// <summary>
        /// Asset model is intended for use in customer substation.
        /// </summary>
        customerSubstation,
        /// <summary>
        /// Asset model is intended for use in distribution overhead network.
        /// </summary>
        distributionOverhead,
        /// <summary>
        /// Asset model is intended for use in underground distribution network.
        /// </summary>
        distributionUnderground,
        /// <summary>
        /// Other kind of asset model usage.
        /// </summary>
        other,
        /// <summary>
        /// Asset model is intended for use as streetlight.
        /// </summary>
        streetlight,
        /// <summary>
        /// Asset model is intended for use in substation.
        /// </summary>
        substation,
        /// <summary>
        /// Asset model is intended for use in transmission network.
        /// </summary>
        transmission,
        /// <summary>
        /// Usage of the asset model is unknown.
        /// </summary>
        unknown,
    }
     
    /// <summary>
    /// Common representation for reading values. Note that a reading value may
    /// have multiple qualities, as produced by various systems ('ReadingQuality.source').
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#BaseReading")]
    public partial class BaseReading : ModelObject, IModelObject
    {
        public BaseReading(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// (used only when there are detailed auditing requirements) Date and time
        /// at which the reading was first delivered to the metering system.
        /// </summary>
        public object reportedDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(reportedDateTime));
            set => ObjectData.SetAttribute<object>(nameof(reportedDateTime), value);
        }
         
        /// <summary>
        /// System that originally supplied the reading (e.g., customer, AMI system,
        /// handheld reading system, another enterprise system, etc.).
        /// </summary>
        public string source
        {
            get => ObjectData.GetAttribute<string>(nameof(source));
            set => ObjectData.SetAttribute<string>(nameof(source), value);
        }
         
        /// <summary>
        /// Value of this reading.
        /// </summary>
        public string value
        {
            get => ObjectData.GetAttribute<string>(nameof(value));
            set => ObjectData.SetAttribute<string>(nameof(value), value);
        }
         
        /// <summary>
        /// All qualities of this reading.
        /// </summary>
        public ReadingQuality[]? ReadingQualities
        {
            get => ObjectData.GetAssoc1ToM<ReadingQuality>(nameof(ReadingQualities));
        }
         
        public void AddToReadingQualities(ReadingQuality value)
        {
            ObjectData.AddAssoc1ToM(nameof(ReadingQualities), value);
        }
         
        public void RemoveFromReadingQualities(ReadingQuality value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ReadingQualities), value);
        }
         
        public void RemoveAllFromReadingQualities()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ReadingQualities));
        }
         
        /// <summary>
        /// Start and end of the period for those readings whose type has a time attribute
        /// such as 'billing', seasonal' or 'forTheSpecifiedPeriod'.
        /// </summary>
        public DateTimeInterval timePeriod
        {
            get => ObjectData.GetAttribute<DateTimeInterval>(nameof(timePeriod));
            set => ObjectData.SetAttribute<DateTimeInterval>(nameof(timePeriod), value);
        }
         
    }
     
    /// <summary>
    /// A single path for the collection or reporting of register values over a
    /// period of time. For example, a register which measures forward energy can
    /// have two channels, one providing bulk quantity readings and the other providing
    /// interval readings of a fixed interval size.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Channel")]
    public partial class Channel : IdentifiedObject, IModelObject
    {
        public Channel(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// If true, the data is being calculated by an enterprise system rather than
        /// metered directly.
        /// </summary>
        public bool isVirtual
        {
            get => ObjectData.GetAttribute<bool>(nameof(isVirtual));
            set => ObjectData.SetAttribute<bool>(nameof(isVirtual), value);
        }
         
        /// <summary>
        /// Reading type for register values reported/collected by this channel.
        /// </summary>
        public ReadingType? ReadingType
        {
            get => ObjectData.GetAssoc1To1<ReadingType>(nameof(ReadingType));
            set => ObjectData.SetAssoc1To1(nameof(ReadingType), value);
        }
         
    }
     
    /// <summary>
    /// Kind of communication direction.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ComDirectionKind")]
    public enum ComDirectionKind
    {
        /// <summary>
        /// Communication with the device is bi-directional.
        /// </summary>
        biDirectional,
        /// <summary>
        /// Communication is from device.
        /// </summary>
        fromDevice,
        /// <summary>
        /// Communication is to device.
        /// </summary>
        toDevice,
    }
     
    /// <summary>
    /// Communication function of communication equipment or a device such as a
    /// meter.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ComFunction")]
    public partial class ComFunction : EndDeviceFunction, IModelObject
    {
        public ComFunction(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Communication ID number (e.g. serial number, IP address, telephone number,
        /// etc.) of the AMR module which serves this meter.
        /// </summary>
        public string amrAddress
        {
            get => ObjectData.GetAttribute<string>(nameof(amrAddress));
            set => ObjectData.SetAttribute<string>(nameof(amrAddress), value);
        }
         
        /// <summary>
        /// Communication ID number (e.g. port number, serial number, data collector
        /// ID, etc.) of the parent device associated to this AMR module.
        /// </summary>
        public string amrRouter
        {
            get => ObjectData.GetAttribute<string>(nameof(amrRouter));
            set => ObjectData.SetAttribute<string>(nameof(amrRouter), value);
        }
         
        /// <summary>
        /// Kind of communication direction.
        /// </summary>
        public ComDirectionKind direction
        {
            get => ObjectData.GetAttribute<ComDirectionKind>(nameof(direction));
            set => ObjectData.SetAttribute<ComDirectionKind>(nameof(direction), value);
        }
         
        /// <summary>
        /// Kind of communication technology.
        /// </summary>
        public ComTechnologyKind technology
        {
            get => ObjectData.GetAttribute<ComTechnologyKind>(nameof(technology));
            set => ObjectData.SetAttribute<ComTechnologyKind>(nameof(technology), value);
        }
         
    }
     
    /// <summary>
    /// Kind of communication technology.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ComTechnologyKind")]
    public enum ComTechnologyKind
    {
        /// <summary>
        /// Communicates using a public cellular radio network. A specific variant
        /// of 'rf'.
        /// </summary>
        cellular,
        /// <summary>
        /// Communicates using one or more of a family of frame-based computer networking
        /// technologies conforming to the IEEE 802.3 standard.
        /// </summary>
        ethernet,
        /// <summary>
        /// Communicates using power line communication technologies conforming to
        /// the standards established by the HomePlug Powerline Alliance. A specific
        /// variant of 'plc'.
        /// </summary>
        homePlug,
        /// <summary>
        /// Communicates using a public one-way or two-way radio-based paging network.
        /// A specific variant of 'rf'.
        /// </summary>
        pager,
        /// <summary>
        /// Communicates using a basic, wireline telephone system.
        /// </summary>
        phone,
        /// <summary>
        /// Communicates using power line communication technologies.
        /// </summary>
        plc,
        /// <summary>
        /// Communicates using private or public radio-based technology.
        /// </summary>
        rf,
        /// <summary>
        /// Communicates using a mesh radio technology. A specific variant of 'rf'.
        /// </summary>
        rfMesh,
        /// <summary>
        /// Communicates using radio communication technologies conforming to the standards
        /// established by the ZigBee. A specific variant of 'rf'.
        /// </summary>
        zigbee,
    }
     
    /// <summary>
    /// Used to report details on creation, change or deletion of an entity or
    /// its configuration.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ConfigurationEvent")]
    public partial class ConfigurationEvent : ActivityRecord, IModelObject
    {
        public ConfigurationEvent(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date and time this event has or will become effective.
        /// </summary>
        public object effectiveDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(effectiveDateTime));
            set => ObjectData.SetAttribute<object>(nameof(effectiveDateTime), value);
        }
         
        /// <summary>
        /// Source/initiator of modification.
        /// </summary>
        public string modifiedBy
        {
            get => ObjectData.GetAttribute<string>(nameof(modifiedBy));
            set => ObjectData.SetAttribute<string>(nameof(modifiedBy), value);
        }
         
        /// <summary>
        /// Free text remarks.
        /// </summary>
        public string remark
        {
            get => ObjectData.GetAttribute<string>(nameof(remark));
            set => ObjectData.SetAttribute<string>(nameof(remark), value);
        }
         
    }
     
    /// <summary>
    /// A function that will disconnect and reconnect the customer's load under
    /// defined conditions.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ConnectDisconnectFunction")]
    public partial class ConnectDisconnectFunction : EndDeviceFunction, IModelObject
    {
        public ConnectDisconnectFunction(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Running cumulative count of connect or disconnect events, for the lifetime
        /// of this function or until the value is cleared.
        /// </summary>
        public int eventCount
        {
            get => ObjectData.GetAttribute<int>(nameof(eventCount));
            set => ObjectData.SetAttribute<int>(nameof(eventCount), value);
        }
         
        /// <summary>
        /// True if this function is in the connected state.
        /// </summary>
        public bool isConnected
        {
            get => ObjectData.GetAttribute<bool>(nameof(isConnected));
            set => ObjectData.SetAttribute<bool>(nameof(isConnected), value);
        }
         
        /// <summary>
        /// If set true, the switch may disconnect the service at the end of a specified
        /// time delay after the disconnect signal has been given. If set false, the
        /// switch may disconnect the service immediately after the disconnect signal
        /// has been given. This is typically the case for over current circuit-breakers
        /// which are classified as either instantaneous or slow acting.
        /// </summary>
        public bool isDelayedDiscon
        {
            get => ObjectData.GetAttribute<bool>(nameof(isDelayedDiscon));
            set => ObjectData.SetAttribute<bool>(nameof(isDelayedDiscon), value);
        }
         
        /// <summary>
        /// If set true and if disconnection can be operated locally, the operation
        /// happens automatically. Otherwise it happens manually.
        /// </summary>
        public bool isLocalAutoDisconOp
        {
            get => ObjectData.GetAttribute<bool>(nameof(isLocalAutoDisconOp));
            set => ObjectData.SetAttribute<bool>(nameof(isLocalAutoDisconOp), value);
        }
         
        /// <summary>
        /// If set true and if reconnection can be operated locally, then the operation
        /// happens automatically. Otherwise, it happens manually.
        /// </summary>
        public bool isLocalAutoReconOp
        {
            get => ObjectData.GetAttribute<bool>(nameof(isLocalAutoReconOp));
            set => ObjectData.SetAttribute<bool>(nameof(isLocalAutoReconOp), value);
        }
         
        /// <summary>
        /// If set true and if disconnection can be operated remotely, then the operation
        /// happens automatically. If set false and if disconnection can be operated
        /// remotely, then the operation happens manually.
        /// </summary>
        public bool isRemoteAutoDisconOp
        {
            get => ObjectData.GetAttribute<bool>(nameof(isRemoteAutoDisconOp));
            set => ObjectData.SetAttribute<bool>(nameof(isRemoteAutoDisconOp), value);
        }
         
        /// <summary>
        /// If set true and if reconnection can be operated remotely, then the operation
        /// happens automatically. If set false and if reconnection can be operated
        /// remotely, then the operation happens manually.
        /// </summary>
        public bool isRemoteAutoReconOp
        {
            get => ObjectData.GetAttribute<bool>(nameof(isRemoteAutoReconOp));
            set => ObjectData.SetAttribute<bool>(nameof(isRemoteAutoReconOp), value);
        }
         
        /// <summary>
        /// Information on remote connect disconnect switch.
        /// </summary>
        public RemoteConnectDisconnectInfo rcdInfo
        {
            get => ObjectData.GetAttribute<RemoteConnectDisconnectInfo>(nameof(rcdInfo));
            set => ObjectData.SetAttribute<RemoteConnectDisconnectInfo>(nameof(rcdInfo), value);
        }
         
    }
     
    /// <summary>
    /// Kind of corporate standard.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CorporateStandardKind")]
    public enum CorporateStandardKind
    {
        /// <summary>
        /// Asset model is used experimentally.
        /// </summary>
        experimental,
        /// <summary>
        /// Other kind of corporate standard for the asset model.
        /// </summary>
        other,
        /// <summary>
        /// Asset model is used as corporate standard.
        /// </summary>
        standard,
        /// <summary>
        /// Asset model usage is under evaluation.
        /// </summary>
        underEvaluation,
    }
     
    /// <summary>
    /// Properties of current transformer asset.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CurrentTransformerInfo")]
    public partial class CurrentTransformerInfo : ModelObject, IModelObject
    {
        public CurrentTransformerInfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Number of cores.
        /// </summary>
        public int coreCount
        {
            get => ObjectData.GetAttribute<int>(nameof(coreCount));
            set => ObjectData.SetAttribute<int>(nameof(coreCount), value);
        }
         
        /// <summary>
        /// </summary>
        public string ctClass
        {
            get => ObjectData.GetAttribute<string>(nameof(ctClass));
            set => ObjectData.SetAttribute<string>(nameof(ctClass), value);
        }
         
        /// <summary>
        /// Maximum primary current where the CT still displays linear characteristicts.
        /// </summary>
        public float kneePointCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(kneePointCurrent));
            set => ObjectData.SetAttribute<float>(nameof(kneePointCurrent), value);
        }
         
        /// <summary>
        /// Maximum voltage across the secondary terminals where the CT still displays
        /// linear characteristicts.
        /// </summary>
        public float kneePointVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(kneePointVoltage));
            set => ObjectData.SetAttribute<float>(nameof(kneePointVoltage), value);
        }
         
        /// <summary>
        /// Full load secondary (FLS) rating for primary winding.
        /// </summary>
        public float primaryFlsRating
        {
            get => ObjectData.GetAttribute<float>(nameof(primaryFlsRating));
            set => ObjectData.SetAttribute<float>(nameof(primaryFlsRating), value);
        }
         
        /// <summary>
        /// Rated current on the primary side.
        /// </summary>
        public float ratedCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedCurrent));
            set => ObjectData.SetAttribute<float>(nameof(ratedCurrent), value);
        }
         
        /// <summary>
        /// Full load secondary (FLS) rating for secondary winding.
        /// </summary>
        public float secondaryFlsRating
        {
            get => ObjectData.GetAttribute<float>(nameof(secondaryFlsRating));
            set => ObjectData.SetAttribute<float>(nameof(secondaryFlsRating), value);
        }
         
        /// <summary>
        /// Full load secondary (FLS) rating for tertiary winding.
        /// </summary>
        public float tertiaryFlsRating
        {
            get => ObjectData.GetAttribute<float>(nameof(tertiaryFlsRating));
            set => ObjectData.SetAttribute<float>(nameof(tertiaryFlsRating), value);
        }
         
        /// <summary>
        /// Usage: eg. metering, protection, etc.
        /// </summary>
        public string usage
        {
            get => ObjectData.GetAttribute<string>(nameof(usage));
            set => ObjectData.SetAttribute<string>(nameof(usage), value);
        }
         
        /// <summary>
        /// Maximum ratio between the primary and secondary current.
        /// </summary>
        public Ratio maxRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(maxRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(maxRatio), value);
        }
         
        /// <summary>
        /// Nominal ratio between the primary and secondary current; i.e. 100:5.
        /// </summary>
        public Ratio nominalRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(nominalRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(nominalRatio), value);
        }
         
        /// <summary>
        /// Ratio for the primary winding tap changer.
        /// </summary>
        public Ratio primaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(primaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(primaryRatio), value);
        }
         
        /// <summary>
        /// Ratio for the secondary winding tap changer.
        /// </summary>
        public Ratio secondaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(secondaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(secondaryRatio), value);
        }
         
        /// <summary>
        /// Ratio for the tertiary winding tap changer.
        /// </summary>
        public Ratio tertiaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(tertiaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(tertiaryRatio), value);
        }
         
    }
     
    /// <summary>
    /// Organisation receiving services from service supplier.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Customer")]
    public partial class Customer : OrganisationRole, IModelObject
    {
        public Customer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of customer.
        /// </summary>
        public CustomerKind kind
        {
            get => ObjectData.GetAttribute<CustomerKind>(nameof(kind));
            set => ObjectData.SetAttribute<CustomerKind>(nameof(kind), value);
        }
         
        /// <summary>
        /// Locale designating language to use in communications with this customer.
        /// </summary>
        public string locale
        {
            get => ObjectData.GetAttribute<string>(nameof(locale));
            set => ObjectData.SetAttribute<string>(nameof(locale), value);
        }
         
        /// <summary>
        /// (if applicable) Public utilities commission (PUC) identification number.
        /// </summary>
        public string pucNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(pucNumber));
            set => ObjectData.SetAttribute<string>(nameof(pucNumber), value);
        }
         
        /// <summary>
        /// True if customer organisation has special service needs such as life support,
        /// hospitals, etc.
        /// </summary>
        public string specialNeed
        {
            get => ObjectData.GetAttribute<string>(nameof(specialNeed));
            set => ObjectData.SetAttribute<string>(nameof(specialNeed), value);
        }
         
        /// <summary>
        /// (deprecated) (use 'priority' instead) True if this is an important customer.
        /// Importance is for matters different than those in 'specialNeed' attribute.
        /// </summary>
        public bool vip
        {
            get => ObjectData.GetAttribute<bool>(nameof(vip));
            set => ObjectData.SetAttribute<bool>(nameof(vip), value);
        }
         
        /// <summary>
        /// All agreements of this customer.
        /// </summary>
        public CustomerAgreement[]? CustomerAgreements
        {
            get => ObjectData.GetAssoc1ToM<CustomerAgreement>(nameof(CustomerAgreements));
        }
         
        public void AddToCustomerAgreements(CustomerAgreement value)
        {
            ObjectData.AddAssoc1ToM(nameof(CustomerAgreements), value);
        }
         
        public void RemoveFromCustomerAgreements(CustomerAgreement value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(CustomerAgreements), value);
        }
         
        public void RemoveAllFromCustomerAgreements()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(CustomerAgreements));
        }
         
        /// <summary>
        /// All end devices of this customer.
        /// </summary>
        public EndDevice[]? EndDevices
        {
            get => ObjectData.GetAssoc1ToM<EndDevice>(nameof(EndDevices));
        }
         
        public void AddToEndDevices(EndDevice value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveFromEndDevices(EndDevice value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveAllFromEndDevices()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDevices));
        }
         
        /// <summary>
        /// Status of this customer.
        /// </summary>
        public Status status
        {
            get => ObjectData.GetAttribute<Status>(nameof(status));
            set => ObjectData.SetAttribute<Status>(nameof(status), value);
        }
         
    }
     
    /// <summary>
    /// Agreement between the customer and the service supplier to pay for service
    /// at a specific service location. It records certain billing information
    /// about the type of service provided at the service location and is used
    /// during charge creation to determine the type of service.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CustomerAgreement")]
    public partial class CustomerAgreement : Agreement, IModelObject
    {
        public CustomerAgreement(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Load management code.
        /// </summary>
        public string loadMgmt
        {
            get => ObjectData.GetAttribute<string>(nameof(loadMgmt));
            set => ObjectData.SetAttribute<string>(nameof(loadMgmt), value);
        }
         
        /// <summary>
        /// Customer for this agreement.
        /// </summary>
        public Customer? Customer
        {
            get => ObjectData.GetAssoc1To1<Customer>(nameof(Customer));
            set => ObjectData.SetAssoc1To1(nameof(Customer), value);
        }
         
        /// <summary>
        /// Service category for this agreement.
        /// </summary>
        public ServiceCategory? ServiceCategory
        {
            get => ObjectData.GetAssoc1To1<ServiceCategory>(nameof(ServiceCategory));
            set => ObjectData.SetAssoc1To1(nameof(ServiceCategory), value);
        }
         
        /// <summary>
        /// All service delivery points regulated by this customer agreement.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// Kind of customer.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CustomerKind")]
    public enum CustomerKind
    {
        /// <summary>
        /// Commercial industrial customer.
        /// </summary>
        commercialIndustrial,
        /// <summary>
        /// Customer as energy service scheduler.
        /// </summary>
        energyServiceScheduler,
        /// <summary>
        /// Customer as energy service supplier.
        /// </summary>
        energyServiceSupplier,
        /// <summary>
        /// Internal use customer.
        /// </summary>
        internalUse,
        /// <summary>
        /// Other kind of customer.
        /// </summary>
        other,
        /// <summary>
        /// Pumping load customer.
        /// </summary>
        pumpingLoad,
        /// <summary>
        /// Residential customer.
        /// </summary>
        residential,
        /// <summary>
        /// Residential and commercial customer.
        /// </summary>
        residentialAndCommercial,
        /// <summary>
        /// Residential and streetlight customer.
        /// </summary>
        residentialAndStreetlight,
        /// <summary>
        /// Residential farm service customer.
        /// </summary>
        residentialFarmService,
        /// <summary>
        /// Residential streetlight or other related customer.
        /// </summary>
        residentialStreetlightOthers,
        /// <summary>
        /// Wind machine customer.
        /// </summary>
        windMachine,
    }
     
    /// <summary>
    /// Interval between two date and time points, where the interval includes
    /// the start time but excludes end time.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DateTimeInterval")]
    public partial class DateTimeInterval : ModelObject, IModelObject
    {
        public DateTimeInterval(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// End date and time of this interval. The end date and time where the interval
        /// is defined up to, but excluded.
        /// </summary>
        public object end
        {
            get => ObjectData.GetAttribute<object>(nameof(end));
            set => ObjectData.SetAttribute<object>(nameof(end), value);
        }
         
        /// <summary>
        /// Start date and time of this interval. The start date and time is included
        /// in the defined interval.
        /// </summary>
        public object start
        {
            get => ObjectData.GetAttribute<object>(nameof(start));
            set => ObjectData.SetAttribute<object>(nameof(start), value);
        }
         
    }
     
    /// <summary>
    /// Parent class for different groupings of information collected and managed
    /// as a part of a business process. It will frequently contain references
    /// to other objects, such as assets, people and power system resources.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Document")]
    public partial class Document : IdentifiedObject, IModelObject
    {
        public Document(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All configuration events created for this document.
        /// </summary>
        public ConfigurationEvent[]? ConfigurationEvents
        {
            get => ObjectData.GetAssoc1ToM<ConfigurationEvent>(nameof(ConfigurationEvents));
        }
         
        public void AddToConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveFromConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveAllFromConfigurationEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConfigurationEvents));
        }
         
    }
     
    /// <summary>
    /// Asset container that performs one or more end device functions. One type
    /// of end device is a meter which can perform metering, load management, connect/disconnect,
    /// accounting functions, etc. Some end devices, such as ones monitoring and
    /// controlling air conditioners, refrigerators, pool pumps may be connected
    /// to a meter. All end devices may have communication capability defined by
    /// the associated communication function(s). An end device may be owned by
    /// a consumer, a service provider, utility or otherwise.
    /// There may be a related end device function that identifies a sensor or
    /// control point within a metering application or communications systems (e.g.,
    /// water, gas, electricity).
    /// Some devices may use an optical port that conforms to the ANSI C12.18 standard
    /// for communications.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDevice")]
    public partial class EndDevice : AssetContainer, IModelObject
    {
        public EndDevice(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Installation code.
        /// </summary>
        public string installCode
        {
            get => ObjectData.GetAttribute<string>(nameof(installCode));
            set => ObjectData.SetAttribute<string>(nameof(installCode), value);
        }
         
        /// <summary>
        /// If true, this is a premises area network (PAN) device.
        /// </summary>
        public bool isPan
        {
            get => ObjectData.GetAttribute<bool>(nameof(isPan));
            set => ObjectData.SetAttribute<bool>(nameof(isPan), value);
        }
         
        /// <summary>
        /// If true, there is no physical device. As an example, a virtual meter can
        /// be defined to aggregate the consumption for two or more physical meters.
        /// Otherwise, this is a physical hardware device.
        /// </summary>
        public bool isVirtual
        {
            get => ObjectData.GetAttribute<bool>(nameof(isVirtual));
            set => ObjectData.SetAttribute<bool>(nameof(isVirtual), value);
        }
         
        /// <summary>
        /// Time zone offset relative to GMT for the location of this end device.
        /// </summary>
        public float timeZoneOffset
        {
            get => ObjectData.GetAttribute<float>(nameof(timeZoneOffset));
            set => ObjectData.SetAttribute<float>(nameof(timeZoneOffset), value);
        }
         
        /// <summary>
        /// Customer owning this end device.
        /// </summary>
        public Customer? Customer
        {
            get => ObjectData.GetAssoc1To1<Customer>(nameof(Customer));
            set => ObjectData.SetAssoc1To1(nameof(Customer), value);
        }
         
        /// <summary>
        /// All end device functions this end device performs.
        /// </summary>
        public EndDeviceFunction[]? EndDeviceFunctions
        {
            get => ObjectData.GetAssoc1ToM<EndDeviceFunction>(nameof(EndDeviceFunctions));
        }
         
        public void AddToEndDeviceFunctions(EndDeviceFunction value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDeviceFunctions), value);
        }
         
        public void RemoveFromEndDeviceFunctions(EndDeviceFunction value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDeviceFunctions), value);
        }
         
        public void RemoveAllFromEndDeviceFunctions()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDeviceFunctions));
        }
         
        /// <summary>
        /// End device data.
        /// </summary>
        public EndDeviceInfo? EndDeviceInfo
        {
            get => ObjectData.GetAssoc1To1<EndDeviceInfo>(nameof(EndDeviceInfo));
            set => ObjectData.SetAssoc1To1(nameof(EndDeviceInfo), value);
        }
         
        /// <summary>
        /// Usage point to which this end device belongs.
        /// </summary>
        public UsagePoint? UsagePoint
        {
            get => ObjectData.GetAssoc1To1<UsagePoint>(nameof(UsagePoint));
            set => ObjectData.SetAssoc1To1(nameof(UsagePoint), value);
        }
         
    }
     
    /// <summary>
    /// Inherent capabilities of an end device (i.e., the functions it supports).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceCapability")]
    public partial class EndDeviceCapability : ModelObject, IModelObject
    {
        public EndDeviceCapability(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// True if autonomous DST (daylight saving time) function is supported.
        /// </summary>
        public bool autonomousDst
        {
            get => ObjectData.GetAttribute<bool>(nameof(autonomousDst));
            set => ObjectData.SetAttribute<bool>(nameof(autonomousDst), value);
        }
         
        /// <summary>
        /// True if communication function is supported.
        /// </summary>
        public bool communication
        {
            get => ObjectData.GetAttribute<bool>(nameof(communication));
            set => ObjectData.SetAttribute<bool>(nameof(communication), value);
        }
         
        /// <summary>
        /// True if connect and disconnect function is supported.
        /// </summary>
        public bool connectDisconnect
        {
            get => ObjectData.GetAttribute<bool>(nameof(connectDisconnect));
            set => ObjectData.SetAttribute<bool>(nameof(connectDisconnect), value);
        }
         
        /// <summary>
        /// True if demand response function is supported.
        /// </summary>
        public bool demandResponse
        {
            get => ObjectData.GetAttribute<bool>(nameof(demandResponse));
            set => ObjectData.SetAttribute<bool>(nameof(demandResponse), value);
        }
         
        /// <summary>
        /// True if electric metering function is supported.
        /// </summary>
        public bool electricMetering
        {
            get => ObjectData.GetAttribute<bool>(nameof(electricMetering));
            set => ObjectData.SetAttribute<bool>(nameof(electricMetering), value);
        }
         
        /// <summary>
        /// True if gas metering function is supported.
        /// </summary>
        public bool gasMetering
        {
            get => ObjectData.GetAttribute<bool>(nameof(gasMetering));
            set => ObjectData.SetAttribute<bool>(nameof(gasMetering), value);
        }
         
        /// <summary>
        /// True if metrology function is supported.
        /// </summary>
        public bool metrology
        {
            get => ObjectData.GetAttribute<bool>(nameof(metrology));
            set => ObjectData.SetAttribute<bool>(nameof(metrology), value);
        }
         
        /// <summary>
        /// True if on request read function is supported.
        /// </summary>
        public bool onRequestRead
        {
            get => ObjectData.GetAttribute<bool>(nameof(onRequestRead));
            set => ObjectData.SetAttribute<bool>(nameof(onRequestRead), value);
        }
         
        /// <summary>
        /// True if outage history function is supported.
        /// </summary>
        public bool outageHistory
        {
            get => ObjectData.GetAttribute<bool>(nameof(outageHistory));
            set => ObjectData.SetAttribute<bool>(nameof(outageHistory), value);
        }
         
        /// <summary>
        /// True if device performs pressure compensation for metered quantities.
        /// </summary>
        public bool pressureCompensation
        {
            get => ObjectData.GetAttribute<bool>(nameof(pressureCompensation));
            set => ObjectData.SetAttribute<bool>(nameof(pressureCompensation), value);
        }
         
        /// <summary>
        /// True if pricing information is supported.
        /// </summary>
        public bool pricingInfo
        {
            get => ObjectData.GetAttribute<bool>(nameof(pricingInfo));
            set => ObjectData.SetAttribute<bool>(nameof(pricingInfo), value);
        }
         
        /// <summary>
        /// True if device produces pulse outputs.
        /// </summary>
        public bool pulseOutput
        {
            get => ObjectData.GetAttribute<bool>(nameof(pulseOutput));
            set => ObjectData.SetAttribute<bool>(nameof(pulseOutput), value);
        }
         
        /// <summary>
        /// True if relays programming function is supported.
        /// </summary>
        public bool relaysProgramming
        {
            get => ObjectData.GetAttribute<bool>(nameof(relaysProgramming));
            set => ObjectData.SetAttribute<bool>(nameof(relaysProgramming), value);
        }
         
        /// <summary>
        /// True if reverse flow function is supported.
        /// </summary>
        public bool reverseFlow
        {
            get => ObjectData.GetAttribute<bool>(nameof(reverseFlow));
            set => ObjectData.SetAttribute<bool>(nameof(reverseFlow), value);
        }
         
        /// <summary>
        /// True if device performs super compressibility compensation for metered
        /// quantities.
        /// </summary>
        public bool superCompressibilityCompensation
        {
            get => ObjectData.GetAttribute<bool>(nameof(superCompressibilityCompensation));
            set => ObjectData.SetAttribute<bool>(nameof(superCompressibilityCompensation), value);
        }
         
        /// <summary>
        /// True if device performs temperature compensation for metered quantities.
        /// </summary>
        public bool temperatureCompensation
        {
            get => ObjectData.GetAttribute<bool>(nameof(temperatureCompensation));
            set => ObjectData.SetAttribute<bool>(nameof(temperatureCompensation), value);
        }
         
        /// <summary>
        /// True if the displaying of text messages is supported.
        /// </summary>
        public bool textMessage
        {
            get => ObjectData.GetAttribute<bool>(nameof(textMessage));
            set => ObjectData.SetAttribute<bool>(nameof(textMessage), value);
        }
         
        /// <summary>
        /// True if water metering function is supported.
        /// </summary>
        public bool waterMetering
        {
            get => ObjectData.GetAttribute<bool>(nameof(waterMetering));
            set => ObjectData.SetAttribute<bool>(nameof(waterMetering), value);
        }
         
    }
     
    /// <summary>
    /// Instructs an end device (or an end device group) to perform a specified
    /// action.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceControl")]
    public partial class EndDeviceControl : IdentifiedObject, IModelObject
    {
        public EndDeviceControl(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Reason for the control action that allows to determine how to continue
        /// processing. For example, disconnect meter command may require different
        /// processing by the receiving system if it has been issued for a network-related
        /// reason (protection) or for a payment-related reason.
        /// </summary>
        public string reason
        {
            get => ObjectData.GetAttribute<string>(nameof(reason));
            set => ObjectData.SetAttribute<string>(nameof(reason), value);
        }
         
        /// <summary>
        /// Type of this end device control.
        /// </summary>
        public EndDeviceControlType? EndDeviceControlType
        {
            get => ObjectData.GetAssoc1To1<EndDeviceControlType>(nameof(EndDeviceControlType));
            set => ObjectData.SetAssoc1To1(nameof(EndDeviceControlType), value);
        }
         
        /// <summary>
        /// All end devices receiving commands from this end device control.
        /// </summary>
        public EndDevice[]? EndDevices
        {
            get => ObjectData.GetAssoc1ToM<EndDevice>(nameof(EndDevices));
        }
         
        public void AddToEndDevices(EndDevice value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveFromEndDevices(EndDevice value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveAllFromEndDevices()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDevices));
        }
         
        /// <summary>
        /// All usage points receiving commands from this end device control.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// Detailed description for a control produced by an end device. Values in
    /// attributes allow for creation of recommended codes to be used for identifying
    /// end device controls as follows: <type>.<domain>.<subDomain>.<eventOrAction>.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceControlType")]
    public partial class EndDeviceControlType : IdentifiedObject, IModelObject
    {
        public EndDeviceControlType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// High-level nature of the control.
        /// </summary>
        public string domain
        {
            get => ObjectData.GetAttribute<string>(nameof(domain));
            set => ObjectData.SetAttribute<string>(nameof(domain), value);
        }
         
        /// <summary>
        /// The most specific part of this control type. It is mainly in the form of
        /// a verb that gives action to the control that just occurred.
        /// </summary>
        public string eventOrAction
        {
            get => ObjectData.GetAttribute<string>(nameof(eventOrAction));
            set => ObjectData.SetAttribute<string>(nameof(eventOrAction), value);
        }
         
        /// <summary>
        /// More specific nature of the control, as a further sub-categorisation of
        /// 'domain'.
        /// </summary>
        public string subDomain
        {
            get => ObjectData.GetAttribute<string>(nameof(subDomain));
            set => ObjectData.SetAttribute<string>(nameof(subDomain), value);
        }
         
        /// <summary>
        /// Type of physical device from which the control was created. A value of
        /// zero (0) can be used when the source is unknown.
        /// </summary>
        public string type
        {
            get => ObjectData.GetAttribute<string>(nameof(type));
            set => ObjectData.SetAttribute<string>(nameof(type), value);
        }
         
    }
     
    /// <summary>
    /// Event detected by a device function associated with the end device.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceEvent")]
    public partial class EndDeviceEvent : ActivityRecord, IModelObject
    {
        public EndDeviceEvent(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All details of this end device event.
        /// </summary>
        public EndDeviceEventDetail[]? EndDeviceEventDetails
        {
            get => ObjectData.GetAssoc1ToM<EndDeviceEventDetail>(nameof(EndDeviceEventDetails));
        }
         
        public void AddToEndDeviceEventDetails(EndDeviceEventDetail value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDeviceEventDetails), value);
        }
         
        public void RemoveFromEndDeviceEventDetails(EndDeviceEventDetail value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDeviceEventDetails), value);
        }
         
        public void RemoveAllFromEndDeviceEventDetails()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDeviceEventDetails));
        }
         
        /// <summary>
        /// Type of this end device event.
        /// </summary>
        public EndDeviceEventType? EndDeviceEventType
        {
            get => ObjectData.GetAssoc1To1<EndDeviceEventType>(nameof(EndDeviceEventType));
            set => ObjectData.SetAssoc1To1(nameof(EndDeviceEventType), value);
        }
         
        /// <summary>
        /// Usage point for which this end device event is reported.
        /// </summary>
        public UsagePoint? UsagePoint
        {
            get => ObjectData.GetAssoc1To1<UsagePoint>(nameof(UsagePoint));
            set => ObjectData.SetAssoc1To1(nameof(UsagePoint), value);
        }
         
    }
     
    /// <summary>
    /// Name-value pair, specific to end device events.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceEventDetail")]
    public partial class EndDeviceEventDetail : ModelObject, IModelObject
    {
        public EndDeviceEventDetail(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Name.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// Value, including unit information.
        /// </summary>
        public StringQuantity value
        {
            get => ObjectData.GetAttribute<StringQuantity>(nameof(value));
            set => ObjectData.SetAttribute<StringQuantity>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// Detailed description for an event produced by an end device. Values in
    /// attributes allow for creation of recommended codes to be used for identifying
    /// end device events as follows: <type>.<domain>.<subDomain>.<eventOrAction>.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceEventType")]
    public partial class EndDeviceEventType : IdentifiedObject, IModelObject
    {
        public EndDeviceEventType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// High-level nature of the event. By properly classifying events by a small
        /// set of domain codes, a system can more easily run reports based on the
        /// types of events that have occurred or been received.
        /// </summary>
        public string domain
        {
            get => ObjectData.GetAttribute<string>(nameof(domain));
            set => ObjectData.SetAttribute<string>(nameof(domain), value);
        }
         
        /// <summary>
        /// The most specific part of this event type. It is mainly in the form of
        /// a verb that gives action to the event that just occurred.
        /// </summary>
        public string eventOrAction
        {
            get => ObjectData.GetAttribute<string>(nameof(eventOrAction));
            set => ObjectData.SetAttribute<string>(nameof(eventOrAction), value);
        }
         
        /// <summary>
        /// More specific nature of the event, as a further sub-categorisation of 'domain'.
        /// </summary>
        public string subDomain
        {
            get => ObjectData.GetAttribute<string>(nameof(subDomain));
            set => ObjectData.SetAttribute<string>(nameof(subDomain), value);
        }
         
        /// <summary>
        /// Type of physical device from which the event was created. A value of zero
        /// (0) can be used when the source is unknown.
        /// </summary>
        public string type
        {
            get => ObjectData.GetAttribute<string>(nameof(type));
            set => ObjectData.SetAttribute<string>(nameof(type), value);
        }
         
    }
     
    /// <summary>
    /// Function performed by an end device such as a meter, communication equipment,
    /// controllers, etc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceFunction")]
    public partial class EndDeviceFunction : AssetFunction, IModelObject
    {
        public EndDeviceFunction(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// True if the function is enabled.
        /// </summary>
        public bool enabled
        {
            get => ObjectData.GetAttribute<bool>(nameof(enabled));
            set => ObjectData.SetAttribute<bool>(nameof(enabled), value);
        }
         
        /// <summary>
        /// All registers for quantities metered by this end device function.
        /// </summary>
        public Register[]? Registers
        {
            get => ObjectData.GetAssoc1ToM<Register>(nameof(Registers));
        }
         
        public void AddToRegisters(Register value)
        {
            ObjectData.AddAssoc1ToM(nameof(Registers), value);
        }
         
        public void RemoveFromRegisters(Register value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Registers), value);
        }
         
        public void RemoveAllFromRegisters()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Registers));
        }
         
    }
     
    /// <summary>
    /// Kind of end device function.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceFunctionKind")]
    public enum EndDeviceFunctionKind
    {
        /// <summary>
        /// Autonomous application of daylight saving time (DST).
        /// </summary>
        autonomousDst,
        /// <summary>
        /// Demand response functions.
        /// </summary>
        demandResponse,
        /// <summary>
        /// Electricity metering.
        /// </summary>
        electricMetering,
        /// <summary>
        /// Gas metering.
        /// </summary>
        gasMetering,
        /// <summary>
        /// Presentation of metered values to a user or another system (always a function
        /// of a meter, but might not be supported by a load control unit).
        /// </summary>
        metrology,
        /// <summary>
        /// On-request reads.
        /// </summary>
        onRequestRead,
        /// <summary>
        /// Reporting historical power interruption data.
        /// </summary>
        outageHistory,
        /// <summary>
        /// Support for one or more relays that may be programmable in the meter (and
        /// tied to TOU, time pulse, load control or other functions).
        /// </summary>
        relaysProgramming,
        /// <summary>
        /// Detection and monitoring of reverse flow.
        /// </summary>
        reverseFlow,
        /// <summary>
        /// Water metering.
        /// </summary>
        waterMetering,
    }
     
    /// <summary>
    /// End device data.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDeviceInfo")]
    public partial class EndDeviceInfo : ModelObject, IModelObject
    {
        public EndDeviceInfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// If true, this is a solid state end device (as opposed to a mechanical or
        /// electromechanical device).
        /// </summary>
        public bool isSolidState
        {
            get => ObjectData.GetAttribute<bool>(nameof(isSolidState));
            set => ObjectData.SetAttribute<bool>(nameof(isSolidState), value);
        }
         
        /// <summary>
        /// Number of potential phases the end device supports, typically 0, 1 or 3.
        /// </summary>
        public int phaseCount
        {
            get => ObjectData.GetAttribute<int>(nameof(phaseCount));
            set => ObjectData.SetAttribute<int>(nameof(phaseCount), value);
        }
         
        /// <summary>
        /// Rated current.
        /// </summary>
        public float ratedCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedCurrent));
            set => ObjectData.SetAttribute<float>(nameof(ratedCurrent), value);
        }
         
        /// <summary>
        /// Rated voltage.
        /// </summary>
        public float ratedVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedVoltage));
            set => ObjectData.SetAttribute<float>(nameof(ratedVoltage), value);
        }
         
        /// <summary>
        /// Inherent capabilities of the device (i.e., the functions it supports).
        /// </summary>
        public EndDeviceCapability capability
        {
            get => ObjectData.GetAttribute<EndDeviceCapability>(nameof(capability));
            set => ObjectData.SetAttribute<EndDeviceCapability>(nameof(capability), value);
        }
         
    }
     
    /// <summary>
    /// Generic user of energy - a point of consumption on the power system model.
    /// EnergyConsumer.pfixed, .qfixed, .pfixedPct and .qfixedPct have meaning
    /// only if there is no LoadResponseCharacteristic associated with EnergyConsumer
    /// or if LoadResponseCharacteristic.exponentModel is set to False.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EnergyConsumer")]
    public partial class EnergyConsumer : ModelObject, IModelObject
    {
        public EnergyConsumer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Number of individual customers represented by this demand.
        /// </summary>
        public int customerCount
        {
            get => ObjectData.GetAttribute<int>(nameof(customerCount));
            set => ObjectData.SetAttribute<int>(nameof(customerCount), value);
        }
         
    }
     
    /// <summary>
    /// A generic equivalent for an energy supplier on a transmission or distribution
    /// voltage level.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EnergySource")]
    public partial class EnergySource : ModelObject, IModelObject
    {
        public EnergySource(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The parts of a power system that are physical devices, electronic or mechanical.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Equipment")]
    public partial class Equipment : ModelObject, IModelObject
    {
        public Equipment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All usage points connected to the electrical grid through this equipment.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// This is a root class to provide common identification for all classes needing
    /// identification and naming attributes.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#IdentifiedObject")]
    public partial class IdentifiedObject : ModelObject, IModelObject
    {
        public IdentifiedObject(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public UserAttribute[]? CustomAttributes
        {
            get => ObjectData.GetAssoc1ToM<UserAttribute>(nameof(CustomAttributes));
        }
         
        public void AddToCustomAttributes(UserAttribute value)
        {
            ObjectData.AddAssoc1ToM(nameof(CustomAttributes), value);
        }
         
        public void RemoveFromCustomAttributes(UserAttribute value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(CustomAttributes), value);
        }
         
        public void RemoveAllFromCustomAttributes()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(CustomAttributes));
        }
         
    }
     
    /// <summary>
    /// Time sequence of readings of the same reading type. Contained interval
    /// readings may need conversion through the application of an offset and a
    /// scalar defined in associated pending.
    /// Table 548 shows all association ends of IntervalBlock with other classes.
    /// Table 548  Association ends of Metering::IntervalBlock with other classes
    /// Associations
    /// name
    /// mult to
    /// type
    /// description
    /// 0..*
    /// PendingCalculation
    /// 0..1
    /// PendingCalculation
    /// Pending calculation to apply to interval reading values contained by this
    /// block (after which the resulting reading type is different than the original
    /// because it reflects the conversion result).
    /// 0..*
    /// IntervalReadings
    /// 0..*
    /// IntervalReading
    /// Interval reading contained in this block.
    /// 0..*
    /// ReadingType
    /// 0..1
    /// ReadingType
    /// Type information for interval reading values contained in this block.
    /// 0..*
    /// MeterReading
    /// 0..1
    /// MeterReading
    /// Meter reading containing this interval block.
    /// IntervalReading
    /// Data captured at regular intervals of time. Interval data could be captured
    /// as incremental data, absolute data, or relative data. The source for the
    /// data is usually a tariff quantity or an engineering quantity. Data is typically
    /// captured in time-tagged, uniform, fixed-length intervals of 5 min, 10 min,
    /// 15 min, 30 min, or 60 min.
    /// Note: Interval Data is sometimes also called "Interval Data Readings" (IDR).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#IntervalBlock")]
    public partial class IntervalBlock : ModelObject, IModelObject
    {
        public IntervalBlock(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Interval reading contained in this block.
        /// </summary>
        public IntervalReading[]? IntervalReadings
        {
            get => ObjectData.GetAssoc1ToM<IntervalReading>(nameof(IntervalReadings));
        }
         
        public void AddToIntervalReadings(IntervalReading value)
        {
            ObjectData.AddAssoc1ToM(nameof(IntervalReadings), value);
        }
         
        public void RemoveFromIntervalReadings(IntervalReading value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(IntervalReadings), value);
        }
         
        public void RemoveAllFromIntervalReadings()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(IntervalReadings));
        }
         
        /// <summary>
        /// Type information for interval reading values contained in this block.
        /// </summary>
        public ReadingType? ReadingType
        {
            get => ObjectData.GetAssoc1To1<ReadingType>(nameof(ReadingType));
            set => ObjectData.SetAssoc1To1(nameof(ReadingType), value);
        }
         
    }
     
    /// <summary>
    /// Data captured at regular intervals of time. Interval data could be captured
    /// as incremental data, absolute data, or relative data. The source for the
    /// data is usually a tariff quantity or an engineering quantity. Data is typically
    /// captured in time-tagged, uniform, fixed-length intervals of 5 min, 10 min,
    /// 15 min, 30 min, or 60 min.
    /// Note: Interval Data is sometimes also called "Interval Data Readings" (IDR).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#IntervalReading")]
    public partial class IntervalReading : BaseReading, IModelObject
    {
        public IntervalReading(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The place, scene, or point of something where someone or something has
    /// been, is, and/or will be at a given moment in time. It can be defined with
    /// one or more position points (coordinates) in a given coordinate system.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Location")]
    public partial class Location : IdentifiedObject, IModelObject
    {
        public Location(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// (if applicable) Direction that allows field crews to quickly find a given
        /// asset. For a given location, such as a street address, this is the relative
        /// direction in which to find the asset. For example, a streetlight may be
        /// located at the 'NW' (northwest) corner of the customer's site, or a usage
        /// point may be located on the second floor of an apartment building.
        /// </summary>
        public string direction
        {
            get => ObjectData.GetAttribute<string>(nameof(direction));
            set => ObjectData.SetAttribute<string>(nameof(direction), value);
        }
         
        /// <summary>
        /// (if applicable) Reference to geographical information source, often external
        /// to the utility.
        /// </summary>
        public string geoInfoReference
        {
            get => ObjectData.GetAttribute<string>(nameof(geoInfoReference));
            set => ObjectData.SetAttribute<string>(nameof(geoInfoReference), value);
        }
         
        /// <summary>
        /// Classification by utility's corporate standards and practices, relative
        /// to the location itself (e.g., geographical, functional accounting, etc.,
        /// not a given property that happens to exist at that location).
        /// </summary>
        public string type
        {
            get => ObjectData.GetAttribute<string>(nameof(type));
            set => ObjectData.SetAttribute<string>(nameof(type), value);
        }
         
        /// <summary>
        /// All configuration events created for this location.
        /// </summary>
        public ConfigurationEvent[]? ConfigurationEvents
        {
            get => ObjectData.GetAssoc1ToM<ConfigurationEvent>(nameof(ConfigurationEvents));
        }
         
        public void AddToConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveFromConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveAllFromConfigurationEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConfigurationEvents));
        }
         
        /// <summary>
        /// Coordinate system used to describe position points of this location.
        /// </summary>
        public CoordinateSystem? CoordinateSystem
        {
            get => ObjectData.GetAssoc1To1<CoordinateSystem>(nameof(CoordinateSystem));
            set => ObjectData.SetAssoc1To1(nameof(CoordinateSystem), value);
        }
         
        /// <summary>
        /// Status of this location.
        /// </summary>
        public Status status
        {
            get => ObjectData.GetAttribute<Status>(nameof(status));
            set => ObjectData.SetAttribute<Status>(nameof(status), value);
        }
         
    }
     
    /// <summary>
    /// Physical asset that performs the metering role of the usage point. Used
    /// for measuring consumption and detection of events.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Meter")]
    public partial class Meter : EndDevice, IModelObject
    {
        public Meter(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Meter form designation per ANSI C12.10 or other applicable standard. An
        /// alphanumeric designation denoting the circuit arrangement for which the
        /// meter is applicable and its specific terminal arrangement.
        /// </summary>
        public string formNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(formNumber));
            set => ObjectData.SetAttribute<string>(nameof(formNumber), value);
        }
         
        /// <summary>
        /// All multipliers applied at this meter.
        /// </summary>
        public MeterMultiplier[]? MeterMultipliers
        {
            get => ObjectData.GetAssoc1ToM<MeterMultiplier>(nameof(MeterMultipliers));
        }
         
        public void AddToMeterMultipliers(MeterMultiplier value)
        {
            ObjectData.AddAssoc1ToM(nameof(MeterMultipliers), value);
        }
         
        public void RemoveFromMeterMultipliers(MeterMultiplier value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(MeterMultipliers), value);
        }
         
        public void RemoveAllFromMeterMultipliers()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(MeterMultipliers));
        }
         
        /// <summary>
        /// All meter readings provided by this meter.
        /// </summary>
        public MeterReading[]? MeterReadings
        {
            get => ObjectData.GetAssoc1ToM<MeterReading>(nameof(MeterReadings));
        }
         
        public void AddToMeterReadings(MeterReading value)
        {
            ObjectData.AddAssoc1ToM(nameof(MeterReadings), value);
        }
         
        public void RemoveFromMeterReadings(MeterReading value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(MeterReadings), value);
        }
         
        public void RemoveAllFromMeterReadings()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(MeterReadings));
        }
         
    }
     
    /// <summary>
    /// Multiplier applied at the meter.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#MeterMultiplier")]
    public partial class MeterMultiplier : IdentifiedObject, IModelObject
    {
        public MeterMultiplier(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of multiplier.
        /// </summary>
        public MeterMultiplierKind kind
        {
            get => ObjectData.GetAttribute<MeterMultiplierKind>(nameof(kind));
            set => ObjectData.SetAttribute<MeterMultiplierKind>(nameof(kind), value);
        }
         
        /// <summary>
        /// Multiplier value.
        /// </summary>
        public float value
        {
            get => ObjectData.GetAttribute<float>(nameof(value));
            set => ObjectData.SetAttribute<float>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// Kind of meter multiplier.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#MeterMultiplierKind")]
    public enum MeterMultiplierKind
    {
        /// <summary>
        /// Current transformer ratio used to convert associated quantities to real
        /// measurements.
        /// </summary>
        ctRatio,
        /// <summary>
        /// Test constant.
        /// </summary>
        kE,
        /// <summary>
        /// Meter kh (watthour) constant. The number of watthours that must be applied
        /// to the meter to cause one disk revolution for an electromechanical meter
        /// or the number of watthours represented by one increment pulse for an electronic
        /// meter.
        /// </summary>
        kH,
        /// <summary>
        /// Register multiplier. The number to multiply the register reading by in
        /// order to get kWh.
        /// </summary>
        kR,
        /// <summary>
        /// Potential transformer ratio used to convert associated quantities to real
        /// measurements.
        /// </summary>
        ptRatio,
        /// <summary>
        /// Product of the CT ratio and PT ratio.
        /// </summary>
        transformerRatio,
    }
     
    /// <summary>
    /// Set of values obtained from the meter.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#MeterReading")]
    public partial class MeterReading : IdentifiedObject, IModelObject
    {
        public MeterReading(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All end device events associated with this set of measured values.
        /// </summary>
        public EndDeviceEvent[]? EndDeviceEvents
        {
            get => ObjectData.GetAssoc1ToM<EndDeviceEvent>(nameof(EndDeviceEvents));
        }
         
        public void AddToEndDeviceEvents(EndDeviceEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDeviceEvents), value);
        }
         
        public void RemoveFromEndDeviceEvents(EndDeviceEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDeviceEvents), value);
        }
         
        public void RemoveAllFromEndDeviceEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDeviceEvents));
        }
         
        /// <summary>
        /// All interval blocks contained in this meter reading.
        /// </summary>
        public IntervalBlock[]? IntervalBlocks
        {
            get => ObjectData.GetAssoc1ToM<IntervalBlock>(nameof(IntervalBlocks));
        }
         
        public void AddToIntervalBlocks(IntervalBlock value)
        {
            ObjectData.AddAssoc1ToM(nameof(IntervalBlocks), value);
        }
         
        public void RemoveFromIntervalBlocks(IntervalBlock value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(IntervalBlocks), value);
        }
         
        public void RemoveAllFromIntervalBlocks()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(IntervalBlocks));
        }
         
        /// <summary>
        /// Meter providing this reading.
        /// </summary>
        public Meter? Meter
        {
            get => ObjectData.GetAssoc1To1<Meter>(nameof(Meter));
            set => ObjectData.SetAssoc1To1(nameof(Meter), value);
        }
         
        /// <summary>
        /// All reading values contained within this meter reading.
        /// </summary>
        public Reading[]? Readings
        {
            get => ObjectData.GetAssoc1ToM<Reading>(nameof(Readings));
        }
         
        public void AddToReadings(Reading value)
        {
            ObjectData.AddAssoc1ToM(nameof(Readings), value);
        }
         
        public void RemoveFromReadings(Reading value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Readings), value);
        }
         
        public void RemoveAllFromReadings()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Readings));
        }
         
        /// <summary>
        /// Usage point from which this meter reading (set of values) has been obtained.
        /// </summary>
        public UsagePoint? UsagePoint
        {
            get => ObjectData.GetAssoc1To1<UsagePoint>(nameof(UsagePoint));
            set => ObjectData.SetAssoc1To1(nameof(UsagePoint), value);
        }
         
        /// <summary>
        /// Date and time interval of the data items contained within this meter reading.
        /// </summary>
        public DateTimeInterval valuesInterval
        {
            get => ObjectData.GetAttribute<DateTimeInterval>(nameof(valuesInterval));
            set => ObjectData.SetAttribute<DateTimeInterval>(nameof(valuesInterval), value);
        }
         
    }
     
    /// <summary>
    /// A specification of the metering requirements for a particular point within
    /// a network.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#MetrologyRequirement")]
    public partial class MetrologyRequirement : IdentifiedObject, IModelObject
    {
        public MetrologyRequirement(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Reason for this metrology requirement being specified.
        /// </summary>
        public ReadingReasonKind reason
        {
            get => ObjectData.GetAttribute<ReadingReasonKind>(nameof(reason));
            set => ObjectData.SetAttribute<ReadingReasonKind>(nameof(reason), value);
        }
         
        /// <summary>
        /// All reading types required to be collected by this metrology requirement.
        /// </summary>
        public ReadingType[]? ReadingTypes
        {
            get => ObjectData.GetAssoc1ToM<ReadingType>(nameof(ReadingTypes));
        }
         
        public void AddToReadingTypes(ReadingType value)
        {
            ObjectData.AddAssoc1ToM(nameof(ReadingTypes), value);
        }
         
        public void RemoveFromReadingTypes(ReadingType value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ReadingTypes), value);
        }
         
        public void RemoveAllFromReadingTypes()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ReadingTypes));
        }
         
    }
     
    /// <summary>
    /// The Name class provides the means to define any number of human readable
    /// names for an object. A name is <b>not</b> to be used for defining inter-object
    /// relationships. For inter-object relationships instead use the object identification
    /// 'mRID'.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Name")]
    public partial class Name : ModelObject, IModelObject
    {
        public Name(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Any free text that name the object.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// Type of this name.
        /// </summary>
        public NameType? NameType
        {
            get => ObjectData.GetAssoc1To1<NameType>(nameof(NameType));
            set => ObjectData.SetAssoc1To1(nameof(NameType), value);
        }
         
    }
     
    /// <summary>
    /// Type of name. Possible values for attribute 'name' are implementation dependent
    /// but standard profiles may specify types. An enterprise may have multiple
    /// IT systems each having its own local name for the same object, e.g. a planning
    /// system may have different names from an EMS. An object may also have different
    /// names within the same IT system, e.g. localName as defined in CIM version
    /// 14. The definition from CIM14 is:
    /// The localName is a human readable name of the object. It is a free text
    /// name local to a node in a naming hierarchy similar to a file directory
    /// structure. A power system related naming hierarchy may be: Substation,
    /// VoltageLevel, Equipment etc. Children of the same parent in such a hierarchy
    /// have names that typically are unique among them.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#NameType")]
    public partial class NameType : ModelObject, IModelObject
    {
        public NameType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Description of the name type.
        /// </summary>
        public string description
        {
            get => ObjectData.GetAttribute<string>(nameof(description));
            set => ObjectData.SetAttribute<string>(nameof(description), value);
        }
         
        /// <summary>
        /// Name of the name type.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
    }
     
    /// <summary>
    /// Organisation that might have roles as utility, contractor, supplier, manufacturer,
    /// customer, etc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Organisation")]
    public partial class Organisation : IdentifiedObject, IModelObject
    {
        public Organisation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Electronic address.
        /// </summary>
        public ElectronicAddress electronicAddress
        {
            get => ObjectData.GetAttribute<ElectronicAddress>(nameof(electronicAddress));
            set => ObjectData.SetAttribute<ElectronicAddress>(nameof(electronicAddress), value);
        }
         
        /// <summary>
        /// Phone number.
        /// </summary>
        public TelephoneNumber phone1
        {
            get => ObjectData.GetAttribute<TelephoneNumber>(nameof(phone1));
            set => ObjectData.SetAttribute<TelephoneNumber>(nameof(phone1), value);
        }
         
        /// <summary>
        /// Additional phone number.
        /// </summary>
        public TelephoneNumber phone2
        {
            get => ObjectData.GetAttribute<TelephoneNumber>(nameof(phone2));
            set => ObjectData.SetAttribute<TelephoneNumber>(nameof(phone2), value);
        }
         
        /// <summary>
        /// Postal address, potentially different than 'streetAddress' (e.g., another
        /// city).
        /// </summary>
        public StreetAddress postalAddress
        {
            get => ObjectData.GetAttribute<StreetAddress>(nameof(postalAddress));
            set => ObjectData.SetAttribute<StreetAddress>(nameof(postalAddress), value);
        }
         
        /// <summary>
        /// Street address.
        /// </summary>
        public StreetAddress streetAddress
        {
            get => ObjectData.GetAttribute<StreetAddress>(nameof(streetAddress));
            set => ObjectData.SetAttribute<StreetAddress>(nameof(streetAddress), value);
        }
         
    }
     
    /// <summary>
    /// Identifies a way in which an organisation may participate in the utility
    /// enterprise (e.g., customer, manufacturer, etc).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#OrganisationRole")]
    public partial class OrganisationRole : IdentifiedObject, IModelObject
    {
        public OrganisationRole(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All configuration events created for this organisation role.
        /// </summary>
        public ConfigurationEvent[]? ConfigurationEvents
        {
            get => ObjectData.GetAssoc1ToM<ConfigurationEvent>(nameof(ConfigurationEvents));
        }
         
        public void AddToConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveFromConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveAllFromConfigurationEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConfigurationEvents));
        }
         
        /// <summary>
        /// Organisation having this role.
        /// </summary>
        public Organisation? Organisation
        {
            get => ObjectData.GetAssoc1To1<Organisation>(nameof(Organisation));
            set => ObjectData.SetAssoc1To1(nameof(Organisation), value);
        }
         
    }
     
    /// <summary>
    /// Properties of potential transformer asset.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PotentialTransformerInfo")]
    public partial class PotentialTransformerInfo : ModelObject, IModelObject
    {
        public PotentialTransformerInfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public string ptClass
        {
            get => ObjectData.GetAttribute<string>(nameof(ptClass));
            set => ObjectData.SetAttribute<string>(nameof(ptClass), value);
        }
         
        /// <summary>
        /// Rated voltage on the primary side.
        /// </summary>
        public float ratedVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedVoltage));
            set => ObjectData.SetAttribute<float>(nameof(ratedVoltage), value);
        }
         
        /// <summary>
        /// Ratio for the primary winding tap changer.
        /// </summary>
        public Ratio primaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(primaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(primaryRatio), value);
        }
         
        /// <summary>
        /// Ratio for the secondary winding tap changer.
        /// </summary>
        public Ratio secondaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(secondaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(secondaryRatio), value);
        }
         
        /// <summary>
        /// Ratio for the tertiary winding tap changer.
        /// </summary>
        public Ratio tertiaryRatio
        {
            get => ObjectData.GetAttribute<Ratio>(nameof(tertiaryRatio));
            set => ObjectData.SetAttribute<Ratio>(nameof(tertiaryRatio), value);
        }
         
    }
     
    /// <summary>
    /// Grouping of pricing components and prices used in the creation of customer
    /// charges and the eligibility criteria under which these terms may be offered
    /// to a customer. The reasons for grouping include state, customer classification,
    /// site characteristics, classification (i.e. fee price structure, deposit
    /// price structure, electric service price structure, etc.) and accounting
    /// requirements.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PricingStructure")]
    public partial class PricingStructure : Document, IModelObject
    {
        public PricingStructure(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Unique user-allocated key for this pricing structure, used by company representatives
        /// to identify the correct price structure for allocating to a customer. For
        /// rate schedules it is often prefixed by a state code.
        /// </summary>
        public string code
        {
            get => ObjectData.GetAttribute<string>(nameof(code));
            set => ObjectData.SetAttribute<string>(nameof(code), value);
        }
         
    }
     
    /// <summary>
    /// Asset model by a specific manufacturer.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ProductAssetModel")]
    public partial class ProductAssetModel : IdentifiedObject, IModelObject
    {
        public ProductAssetModel(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of corporate standard for this asset model.
        /// </summary>
        public CorporateStandardKind corporateStandardKind
        {
            get => ObjectData.GetAttribute<CorporateStandardKind>(nameof(corporateStandardKind));
            set => ObjectData.SetAttribute<CorporateStandardKind>(nameof(corporateStandardKind), value);
        }
         
        /// <summary>
        /// Manufacturer's model number.
        /// </summary>
        public string modelNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(modelNumber));
            set => ObjectData.SetAttribute<string>(nameof(modelNumber), value);
        }
         
        /// <summary>
        /// Version number for product model, which indicates vintage of the product.
        /// </summary>
        public string modelVersion
        {
            get => ObjectData.GetAttribute<string>(nameof(modelVersion));
            set => ObjectData.SetAttribute<string>(nameof(modelVersion), value);
        }
         
        /// <summary>
        /// Intended usage for this asset model.
        /// </summary>
        public AssetModelUsageKind usageKind
        {
            get => ObjectData.GetAttribute<AssetModelUsageKind>(nameof(usageKind));
            set => ObjectData.SetAttribute<AssetModelUsageKind>(nameof(usageKind), value);
        }
         
    }
     
    /// <summary>
    /// Fraction specified explicitly with a numerator and denominator, which can
    /// be used to calculate the quotient.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Ratio")]
    public partial class Ratio : ModelObject, IModelObject
    {
        public Ratio(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The part of a fraction that is below the line and that functions as the
        /// divisor of the numerator.
        /// </summary>
        public float denominator
        {
            get => ObjectData.GetAttribute<float>(nameof(denominator));
            set => ObjectData.SetAttribute<float>(nameof(denominator), value);
        }
         
        /// <summary>
        /// The part of a fraction that is above the line and signifies the number
        /// to be divided by the denominator.
        /// </summary>
        public float numerator
        {
            get => ObjectData.GetAttribute<float>(nameof(numerator));
            set => ObjectData.SetAttribute<float>(nameof(numerator), value);
        }
         
    }
     
    /// <summary>
    /// Rational number = 'numerator' / 'denominator'.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RationalNumber")]
    public partial class RationalNumber : ModelObject, IModelObject
    {
        public RationalNumber(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Denominator. Value 1 indicates the number is a simple integer.
        /// </summary>
        public int denominator
        {
            get => ObjectData.GetAttribute<int>(nameof(denominator));
            set => ObjectData.SetAttribute<int>(nameof(denominator), value);
        }
         
        /// <summary>
        /// Numerator.
        /// </summary>
        public int numerator
        {
            get => ObjectData.GetAttribute<int>(nameof(numerator));
            set => ObjectData.SetAttribute<int>(nameof(numerator), value);
        }
         
    }
     
    /// <summary>
    /// Specific value measured by a meter or other asset, or calculated by a system.
    /// Each Reading is associated with a specific ReadingType.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Reading")]
    public partial class Reading : BaseReading, IModelObject
    {
        public Reading(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Reason for this reading being taken.
        /// </summary>
        public ReadingReasonKind reason
        {
            get => ObjectData.GetAttribute<ReadingReasonKind>(nameof(reason));
            set => ObjectData.SetAttribute<ReadingReasonKind>(nameof(reason), value);
        }
         
        /// <summary>
        /// Type information for this reading value.
        /// </summary>
        public ReadingType? ReadingType
        {
            get => ObjectData.GetAssoc1To1<ReadingType>(nameof(ReadingType));
            set => ObjectData.SetAssoc1To1(nameof(ReadingType), value);
        }
         
    }
     
    /// <summary>
    /// Interharmonics are represented as a rational number 'numerator' / 'denominator',
    /// and harmonics are represented using the same mechanism and identified by
    /// 'denominator'=1.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReadingInterharmonic")]
    public partial class ReadingInterharmonic : ModelObject, IModelObject
    {
        public ReadingInterharmonic(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Interharmonic denominator. Value 0 means not applicable. Value 2 is used
        /// in combination with 'numerator'=1 to represent interharmonic 1/2. Finally,
        /// value 1 indicates the harmonic of the order specified with 'numerator'.
        /// </summary>
        public int denominator
        {
            get => ObjectData.GetAttribute<int>(nameof(denominator));
            set => ObjectData.SetAttribute<int>(nameof(denominator), value);
        }
         
        /// <summary>
        /// Interharmonic numerator. Value 0 means not applicable. Value 1 is used
        /// in combination with 'denominator'=2 to represent interharmonic 1/2, and
        /// with 'denominator'=1 it represents fundamental frequency. Finally, values
        /// greater than 1 indicate the harmonic of that order (e.g., 'numerator'=5
        /// is the fifth harmonic).
        /// </summary>
        public int numerator
        {
            get => ObjectData.GetAttribute<int>(nameof(numerator));
            set => ObjectData.SetAttribute<int>(nameof(numerator), value);
        }
         
    }
     
    /// <summary>
    /// Quality of a specific reading value or interval reading value. Note that
    /// more than one quality may be applicable to a given reading. Typically not
    /// used unless problems or unusual conditions occur (i.e., quality for each
    /// reading is assumed to be good unless stated otherwise in associated reading
    /// quality type). It can also be used with the corresponding reading quality
    /// type to indicate that the validation has been performed and succeeded.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReadingQuality")]
    public partial class ReadingQuality : ModelObject, IModelObject
    {
        public ReadingQuality(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Elaboration on the quality code.
        /// </summary>
        public string comment
        {
            get => ObjectData.GetAttribute<string>(nameof(comment));
            set => ObjectData.SetAttribute<string>(nameof(comment), value);
        }
         
        /// <summary>
        /// System acting as the source of the quality code.
        /// </summary>
        public string source
        {
            get => ObjectData.GetAttribute<string>(nameof(source));
            set => ObjectData.SetAttribute<string>(nameof(source), value);
        }
         
        /// <summary>
        /// Date and time at which the quality code was assigned or ascertained.
        /// </summary>
        public object timeStamp
        {
            get => ObjectData.GetAttribute<object>(nameof(timeStamp));
            set => ObjectData.SetAttribute<object>(nameof(timeStamp), value);
        }
         
        /// <summary>
        /// Type of this reading quality.
        /// </summary>
        public ReadingQualityType? ReadingQualityType
        {
            get => ObjectData.GetAssoc1To1<ReadingQualityType>(nameof(ReadingQualityType));
            set => ObjectData.SetAssoc1To1(nameof(ReadingQualityType), value);
        }
         
    }
     
    /// <summary>
    /// Detailed description for a quality of a reading value, produced by an end
    /// device or a system. Values in attributes allow for creation of the recommended
    /// codes to be used for identifying reading value quality codes as follows:
    /// <systemId>.<category>.<subCategory>.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReadingQualityType")]
    public partial class ReadingQualityType : IdentifiedObject, IModelObject
    {
        public ReadingQualityType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// High-level nature of the reading value quality.
        /// </summary>
        public string category
        {
            get => ObjectData.GetAttribute<string>(nameof(category));
            set => ObjectData.SetAttribute<string>(nameof(category), value);
        }
         
        /// <summary>
        /// More specific nature of the reading value quality, as a further sub-categorisation
        /// of 'category'.
        /// </summary>
        public string subCategory
        {
            get => ObjectData.GetAttribute<string>(nameof(subCategory));
            set => ObjectData.SetAttribute<string>(nameof(subCategory), value);
        }
         
        /// <summary>
        /// Identification of the system which has declared the issue with the data
        /// or provided commentary on the data.
        /// </summary>
        public string systemId
        {
            get => ObjectData.GetAttribute<string>(nameof(systemId));
            set => ObjectData.SetAttribute<string>(nameof(systemId), value);
        }
         
    }
     
    /// <summary>
    /// Reason for the reading being taken.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReadingReasonKind")]
    public enum ReadingReasonKind
    {
        /// <summary>
        /// Reading(s) taken or to be taken in response to a billing-related inquiry
        /// by a customer or other party. A variant of 'inquiry'.
        /// </summary>
        billing,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with the resetting of one
        /// or more demand registers in a meter.
        /// </summary>
        demandReset,
        /// <summary>
        /// Reading(s) taken or to be taken in response to an inquiry by a customer
        /// or other party.
        /// </summary>
        inquiry,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with installation of a meter.
        /// </summary>
        installation,
        /// <summary>
        /// Reading(s) taken or to be taken to support management of loads on distribution
        /// networks or devices.
        /// </summary>
        loadManagement,
        /// <summary>
        /// Reading(s) taken or to be taken to support research and analysis of loads
        /// on distribution networks or devices.
        /// </summary>
        loadResearch,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with a customer move-in
        /// event.
        /// </summary>
        moveIn,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with a customer move-out
        /// event.
        /// </summary>
        moveOut,
        /// <summary>
        /// Reading(s) taken or to be taken for some other reason or purpose.
        /// </summary>
        other,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with removal of a meter.
        /// </summary>
        removal,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with a connection or re-connection
        /// of service.
        /// </summary>
        serviceConnect,
        /// <summary>
        /// Reading(s) taken or to be taken in conjunction with a disconnection of
        /// service.
        /// </summary>
        serviceDisconnect,
    }
     
    /// <summary>
    /// Detailed description for a type of a reading value. Values in attributes
    /// allow for the creation of recommended codes to be used for identifying
    /// reading value types as follows: <macroPeriod>.<aggregate>.<measuringPeriod>.<accumulation>.<flowDirection>.<commodity>.<measurementKind>.<interharmonic.numerator>.<interharmonic.denominator>.<argument.numerator>.<argument.denominator>.<tou>.<cpp>.<consumptionTier>.<phases>.<multiplier>.<unit>.<currency>.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReadingType")]
    public partial class ReadingType : IdentifiedObject, IModelObject
    {
        public ReadingType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Accumulation behaviour of a reading over time, usually 'measuringPeriod',
        /// to be used with individual endpoints (as opposed to 'macroPeriod' and 'aggregate'
        /// that are used to describe aggregations of data from individual endpoints).
        /// </summary>
        public AccumulationKind accumulation
        {
            get => ObjectData.GetAttribute<AccumulationKind>(nameof(accumulation));
            set => ObjectData.SetAttribute<AccumulationKind>(nameof(accumulation), value);
        }
         
        /// <summary>
        /// Salient attribute of the reading data aggregated from individual endpoints.
        /// This is mainly used to define a mathematical operation carried out over
        /// 'macroPeriod', but may also be used to describe an attribute of the data
        /// when the 'macroPeriod' is not defined.
        /// </summary>
        public AggregateKind aggregate
        {
            get => ObjectData.GetAttribute<AggregateKind>(nameof(aggregate));
            set => ObjectData.SetAttribute<AggregateKind>(nameof(aggregate), value);
        }
         
        /// <summary>
        /// Commodity being measured.
        /// </summary>
        public CommodityKind commodity
        {
            get => ObjectData.GetAttribute<CommodityKind>(nameof(commodity));
            set => ObjectData.SetAttribute<CommodityKind>(nameof(commodity), value);
        }
         
        /// <summary>
        /// In case of common flat-rate pricing for power, in which all purchases are
        /// at a given rate, 'consumptionTier'=0. Otherwise, the value indicates the
        /// consumption tier, which can be used in conjunction with TOU or CPP pricing.
        /// Consumption tier pricing refers to the method of billing in which a certain
        /// "block" of energy is purchased/sold at one price, after which the next
        /// block of energy is purchased at another price, and so on, all throughout
        /// a defined period. At the start of the defined period, consumption is initially
        /// zero, and any usage is measured against the first consumption tier ('consumptionTier'=1).
        /// If this block of energy is consumed before the end of the period, energy
        /// consumption moves to be reconed against the second consumption tier ('consumptionTier'=2),
        /// and so on. At the end of the defined period, the consumption accumulator
        /// is reset, and usage within the 'consumptionTier'=1 restarts.
        /// </summary>
        public int consumptionTier
        {
            get => ObjectData.GetAttribute<int>(nameof(consumptionTier));
            set => ObjectData.SetAttribute<int>(nameof(consumptionTier), value);
        }
         
        /// <summary>
        /// Critical peak period (CPP) bucket the reading value is attributed to. Value
        /// 0 means not applicable. Even though CPP is usually considered a specialised
        /// form of time of use 'tou', this attribute is defined explicitly for flexibility.
        /// </summary>
        public int cpp
        {
            get => ObjectData.GetAttribute<int>(nameof(cpp));
            set => ObjectData.SetAttribute<int>(nameof(cpp), value);
        }
         
        /// <summary>
        /// Metering-specific currency.
        /// </summary>
        public Currency currency
        {
            get => ObjectData.GetAttribute<Currency>(nameof(currency));
            set => ObjectData.SetAttribute<Currency>(nameof(currency), value);
        }
         
        /// <summary>
        /// Flow direction for a reading where the direction of flow of the commodity
        /// is important (for electricity measurements this includes current, energy,
        /// power, and demand).
        /// </summary>
        public FlowDirectionKind flowDirection
        {
            get => ObjectData.GetAttribute<FlowDirectionKind>(nameof(flowDirection));
            set => ObjectData.SetAttribute<FlowDirectionKind>(nameof(flowDirection), value);
        }
         
        /// <summary>
        /// Time period of interest that reflects how the reading is viewed or captured
        /// over a long period of time.
        /// </summary>
        public MacroPeriodKind macroPeriod
        {
            get => ObjectData.GetAttribute<MacroPeriodKind>(nameof(macroPeriod));
            set => ObjectData.SetAttribute<MacroPeriodKind>(nameof(macroPeriod), value);
        }
         
        /// <summary>
        /// Identifies "what" is being measured, as refinement of 'commodity'. When
        /// combined with 'unit', it provides detail to the unit of measure. For example,
        /// 'energy' with a unit of measure of 'kWh' indicates to the user that active
        /// energy is being measured, while with 'kVAh' or 'kVArh', it indicates apparent
        /// energy and reactive energy, respectively. 'power' can be combined in a
        /// similar way with various power units of measure: Distortion power ('distortionVoltAmperes')
        /// with 'kVA' is different from 'power' with 'kVA'.
        /// </summary>
        public MeasurementKind measurementKind
        {
            get => ObjectData.GetAttribute<MeasurementKind>(nameof(measurementKind));
            set => ObjectData.SetAttribute<MeasurementKind>(nameof(measurementKind), value);
        }
         
        /// <summary>
        /// Time attribute inherent or fundamental to the reading value (as opposed
        /// to 'macroPeriod' that supplies an "adjective" to describe aspects of a
        /// time period with regard to the measurement). It refers to the way the value
        /// was originally measured and not to the frequency at which it is reported
        /// or presented. For example, an hourly interval of consumption data would
        /// have value 'hourly' as an attribute. However in the case of an hourly sampled
        /// voltage value, the meterReadings schema would carry the 'hourly' interval
        /// size information.
        /// It is common for meters to report demand in a form that is measured over
        /// the course of a portion of an hour, while enterprise applications however
        /// commonly assume the demand (in kW or kVAr) normalised to 1 hour. The system
        /// that receives readings directly from the meter therefore shall perform
        /// this transformation before publishing readings for use by the other enterprise
        /// systems. The scalar used is chosen based on the block size (not any sub-interval
        /// size).
        /// </summary>
        public MeasuringPeriodKind measuringPeriod
        {
            get => ObjectData.GetAttribute<MeasuringPeriodKind>(nameof(measuringPeriod));
            set => ObjectData.SetAttribute<MeasuringPeriodKind>(nameof(measuringPeriod), value);
        }
         
        /// <summary>
        /// Metering-specific phase code.
        /// </summary>
        public PhaseCode phases
        {
            get => ObjectData.GetAttribute<PhaseCode>(nameof(phases));
            set => ObjectData.SetAttribute<PhaseCode>(nameof(phases), value);
        }
         
        /// <summary>
        /// Time of use (TOU) bucket the reading value is attributed to. Value 0 means
        /// not applicable.
        /// </summary>
        public int tou
        {
            get => ObjectData.GetAttribute<int>(nameof(tou));
            set => ObjectData.SetAttribute<int>(nameof(tou), value);
        }
         
        /// <summary>
        /// Metering-specific unit.
        /// </summary>
        public UnitSymbol unit
        {
            get => ObjectData.GetAttribute<UnitSymbol>(nameof(unit));
            set => ObjectData.SetAttribute<UnitSymbol>(nameof(unit), value);
        }
         
        /// <summary>
        /// Argument used to introduce numbers into the unit of measure description
        /// where they are needed (e.g., 4 where the measure needs an argument such
        /// as CEMI(n=4)). Most arguments used in practice however will be integers
        /// (i.e., 'denominator'=1).
        /// Value 0 in 'numerator' and 'denominator' means not applicable.
        /// </summary>
        public RationalNumber argument
        {
            get => ObjectData.GetAttribute<RationalNumber>(nameof(argument));
            set => ObjectData.SetAttribute<RationalNumber>(nameof(argument), value);
        }
         
        /// <summary>
        /// Indication of a "harmonic" or "interharmonic" basis for the measurement.
        /// Value 0 in 'numerator' and 'denominator' means not applicable.
        /// </summary>
        public ReadingInterharmonic interharmonic
        {
            get => ObjectData.GetAttribute<ReadingInterharmonic>(nameof(interharmonic));
            set => ObjectData.SetAttribute<ReadingInterharmonic>(nameof(interharmonic), value);
        }
         
    }
     
    /// <summary>
    /// A device that indicates or records units of the commodity or other quantity
    /// measured.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Register")]
    public partial class Register : IdentifiedObject, IModelObject
    {
        public Register(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// If true, the data it produces is calculated or measured by a device other
        /// than a physical end device/meter. Otherwise, any data streams it produces
        /// are measured by the hardware of the end device/meter itself.
        /// </summary>
        public bool isVirtual
        {
            get => ObjectData.GetAttribute<bool>(nameof(isVirtual));
            set => ObjectData.SetAttribute<bool>(nameof(isVirtual), value);
        }
         
        /// <summary>
        /// Number of digits (dials on a mechanical meter) to the left of the decimal
        /// place; default is normally 5.
        /// </summary>
        public int leftDigitCount
        {
            get => ObjectData.GetAttribute<int>(nameof(leftDigitCount));
            set => ObjectData.SetAttribute<int>(nameof(leftDigitCount), value);
        }
         
        /// <summary>
        /// Number of digits (dials on a mechanical meter) to the right of the decimal
        /// place.
        /// </summary>
        public int rightDigitCount
        {
            get => ObjectData.GetAttribute<int>(nameof(rightDigitCount));
            set => ObjectData.SetAttribute<int>(nameof(rightDigitCount), value);
        }
         
        /// <summary>
        /// Name used for the time of use tier (also known as bin or bucket). For example,
        /// "peak", "off-peak", "TOU Category A", etc.
        /// </summary>
        public string touTierName
        {
            get => ObjectData.GetAttribute<string>(nameof(touTierName));
            set => ObjectData.SetAttribute<string>(nameof(touTierName), value);
        }
         
        /// <summary>
        /// All channels that collect/report values from this register.
        /// </summary>
        public Channel[]? Channels
        {
            get => ObjectData.GetAssoc1ToM<Channel>(nameof(Channels));
        }
         
        public void AddToChannels(Channel value)
        {
            ObjectData.AddAssoc1ToM(nameof(Channels), value);
        }
         
        public void RemoveFromChannels(Channel value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Channels), value);
        }
         
        public void RemoveAllFromChannels()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Channels));
        }
         
        /// <summary>
        /// Clock time interval for register to beging/cease accumulating time of usage
        /// (e.g., start at 8:00 am, stop at 5:00 pm).
        /// </summary>
        public TimeInterval touTier
        {
            get => ObjectData.GetAttribute<TimeInterval>(nameof(touTier));
            set => ObjectData.SetAttribute<TimeInterval>(nameof(touTier), value);
        }
         
    }
     
    /// <summary>
    /// Details of remote connect and disconnect function.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RemoteConnectDisconnectInfo")]
    public partial class RemoteConnectDisconnectInfo : ModelObject, IModelObject
    {
        public RemoteConnectDisconnectInfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Setting of the timeout elapsed time.
        /// </summary>
        public float armedTimeout
        {
            get => ObjectData.GetAttribute<float>(nameof(armedTimeout));
            set => ObjectData.SetAttribute<float>(nameof(armedTimeout), value);
        }
         
        /// <summary>
        /// Voltage limit on customer side of RCD switch above which the connect should
        /// not be made.
        /// </summary>
        public float customerVoltageLimit
        {
            get => ObjectData.GetAttribute<float>(nameof(customerVoltageLimit));
            set => ObjectData.SetAttribute<float>(nameof(customerVoltageLimit), value);
        }
         
        /// <summary>
        /// Limit of energy before disconnect.
        /// </summary>
        public float energyLimit
        {
            get => ObjectData.GetAttribute<float>(nameof(energyLimit));
            set => ObjectData.SetAttribute<float>(nameof(energyLimit), value);
        }
         
        /// <summary>
        /// Start date and time to accumulate energy for energy usage limiting.
        /// </summary>
        public object energyUsageStartDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(energyUsageStartDateTime));
            set => ObjectData.SetAttribute<object>(nameof(energyUsageStartDateTime), value);
        }
         
        /// <summary>
        /// Warning energy limit, used to trigger event code that energy usage is nearing
        /// limit.
        /// </summary>
        public float energyUsageWarning
        {
            get => ObjectData.GetAttribute<float>(nameof(energyUsageWarning));
            set => ObjectData.SetAttribute<float>(nameof(energyUsageWarning), value);
        }
         
        /// <summary>
        /// True if the RCD switch has to be armed before a connect action can be initiated.
        /// </summary>
        public bool isArmConnect
        {
            get => ObjectData.GetAttribute<bool>(nameof(isArmConnect));
            set => ObjectData.SetAttribute<bool>(nameof(isArmConnect), value);
        }
         
        /// <summary>
        /// True if the RCD switch has to be armed before a disconnect action can be
        /// initiated.
        /// </summary>
        public bool isArmDisconnect
        {
            get => ObjectData.GetAttribute<bool>(nameof(isArmDisconnect));
            set => ObjectData.SetAttribute<bool>(nameof(isArmDisconnect), value);
        }
         
        /// <summary>
        /// True if the energy usage is limited and the customer will be disconnected
        /// if they go over the limit.
        /// </summary>
        public bool isEnergyLimiting
        {
            get => ObjectData.GetAttribute<bool>(nameof(isEnergyLimiting));
            set => ObjectData.SetAttribute<bool>(nameof(isEnergyLimiting), value);
        }
         
        /// <summary>
        /// True if load limit has to be checked to issue an immediate disconnect (after
        /// a connect) if load is over the limit.
        /// </summary>
        public bool needsPowerLimitCheck
        {
            get => ObjectData.GetAttribute<bool>(nameof(needsPowerLimitCheck));
            set => ObjectData.SetAttribute<bool>(nameof(needsPowerLimitCheck), value);
        }
         
        /// <summary>
        /// True if voltage limit has to be checked to prevent connect if voltage is
        /// over the limit.
        /// </summary>
        public bool needsVoltageLimitCheck
        {
            get => ObjectData.GetAttribute<bool>(nameof(needsVoltageLimitCheck));
            set => ObjectData.SetAttribute<bool>(nameof(needsVoltageLimitCheck), value);
        }
         
        /// <summary>
        /// Load limit above which the connect should either not take place or should
        /// cause an immediate disconnect.
        /// </summary>
        public float powerLimit
        {
            get => ObjectData.GetAttribute<float>(nameof(powerLimit));
            set => ObjectData.SetAttribute<float>(nameof(powerLimit), value);
        }
         
        /// <summary>
        /// True if pushbutton has to be used for connect.
        /// </summary>
        public bool usePushbutton
        {
            get => ObjectData.GetAttribute<bool>(nameof(usePushbutton));
            set => ObjectData.SetAttribute<bool>(nameof(usePushbutton), value);
        }
         
    }
     
    /// <summary>
    /// Physically controls access to AssetContainers.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Seal")]
    public partial class Seal : IdentifiedObject, IModelObject
    {
        public Seal(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date and time this seal has been applied.
        /// </summary>
        public object appliedDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(appliedDateTime));
            set => ObjectData.SetAttribute<object>(nameof(appliedDateTime), value);
        }
         
        /// <summary>
        /// Condition of seal.
        /// </summary>
        public SealConditionKind condition
        {
            get => ObjectData.GetAttribute<SealConditionKind>(nameof(condition));
            set => ObjectData.SetAttribute<SealConditionKind>(nameof(condition), value);
        }
         
        /// <summary>
        /// Kind of seal.
        /// </summary>
        public SealKind kind
        {
            get => ObjectData.GetAttribute<SealKind>(nameof(kind));
            set => ObjectData.SetAttribute<SealKind>(nameof(kind), value);
        }
         
        /// <summary>
        /// (reserved word) Seal number.
        /// </summary>
        public string sealNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(sealNumber));
            set => ObjectData.SetAttribute<string>(nameof(sealNumber), value);
        }
         
    }
     
    /// <summary>
    /// Kind of seal condition.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SealConditionKind")]
    public enum SealConditionKind
    {
        /// <summary>
        /// Seal is broken.
        /// </summary>
        broken,
        /// <summary>
        /// Seal is locked.
        /// </summary>
        locked,
        /// <summary>
        /// Seal is missing.
        /// </summary>
        missing,
        /// <summary>
        /// Seal is open.
        /// </summary>
        open,
        /// <summary>
        /// Other kind of seal condition.
        /// </summary>
        other,
    }
     
    /// <summary>
    /// Kind of seal.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SealKind")]
    public enum SealKind
    {
        /// <summary>
        /// Lead seal.
        /// </summary>
        lead,
        /// <summary>
        /// Lock seal.
        /// </summary>
        lock,
        /// <summary>
        /// Other kind of seal.
        /// </summary>
        other,
        /// <summary>
        /// Steel seal.
        /// </summary>
        steel,
    }
     
    /// <summary>
    /// Category of service provided to the customer.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceCategory")]
    public partial class ServiceCategory : IdentifiedObject, IModelObject
    {
        public ServiceCategory(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of service.
        /// </summary>
        public ServiceKind kind
        {
            get => ObjectData.GetAttribute<ServiceKind>(nameof(kind));
            set => ObjectData.SetAttribute<ServiceKind>(nameof(kind), value);
        }
         
    }
     
    /// <summary>
    /// Kind of service.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceKind")]
    public enum ServiceKind
    {
        /// <summary>
        /// Electricity service.
        /// </summary>
        electricity,
        /// <summary>
        /// Gas service.
        /// </summary>
        gas,
        /// <summary>
        /// Heat service.
        /// </summary>
        heat,
        /// <summary>
        /// Internet service.
        /// </summary>
        internet,
        /// <summary>
        /// Other kind of service.
        /// </summary>
        other,
        /// <summary>
        /// Rates (e.g. tax, charge, toll, duty, tariff, etc.) service.
        /// </summary>
        rates,
        /// <summary>
        /// Refuse (waster) service.
        /// </summary>
        refuse,
        /// <summary>
        /// Sewerage service.
        /// </summary>
        sewerage,
        /// <summary>
        /// Time service.
        /// </summary>
        time,
        /// <summary>
        /// TV license service.
        /// </summary>
        tvLicence,
        /// <summary>
        /// Water service.
        /// </summary>
        water,
    }
     
    /// <summary>
    /// A real estate location, commonly referred to as premises.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceLocation")]
    public partial class ServiceLocation : ModelObject, IModelObject
    {
        public ServiceLocation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Method for the service person to access this service location. For example,
        /// a description of where to obtain a key if the facility is unmanned and
        /// secured.
        /// </summary>
        public string accessMethod
        {
            get => ObjectData.GetAttribute<string>(nameof(accessMethod));
            set => ObjectData.SetAttribute<string>(nameof(accessMethod), value);
        }
         
        /// <summary>
        /// True if inspection is needed of facilities at this service location. This
        /// could be requested by a customer, due to suspected tampering, environmental
        /// concerns (e.g., a fire in the vicinity), or to correct incompatible data.
        /// </summary>
        public bool needsInspection
        {
            get => ObjectData.GetAttribute<bool>(nameof(needsInspection));
            set => ObjectData.SetAttribute<bool>(nameof(needsInspection), value);
        }
         
        /// <summary>
        /// Problems previously encountered when visiting or performing work on this
        /// location. Examples include: bad dog, violent customer, verbally abusive
        /// occupant, obstructions, safety hazards, etc.
        /// </summary>
        public string siteAccessProblem
        {
            get => ObjectData.GetAttribute<string>(nameof(siteAccessProblem));
            set => ObjectData.SetAttribute<string>(nameof(siteAccessProblem), value);
        }
         
    }
     
    /// <summary>
    /// Multiplier applied at the usage point.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceMultiplier")]
    public partial class ServiceMultiplier : IdentifiedObject, IModelObject
    {
        public ServiceMultiplier(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of multiplier.
        /// </summary>
        public ServiceMultiplierKind kind
        {
            get => ObjectData.GetAttribute<ServiceMultiplierKind>(nameof(kind));
            set => ObjectData.SetAttribute<ServiceMultiplierKind>(nameof(kind), value);
        }
         
        /// <summary>
        /// Multiplier value.
        /// </summary>
        public float value
        {
            get => ObjectData.GetAttribute<float>(nameof(value));
            set => ObjectData.SetAttribute<float>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// Kind of service multiplier.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceMultiplierKind")]
    public enum ServiceMultiplierKind
    {
    }
     
    /// <summary>
    /// Organisation that provides services to customers.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ServiceSupplier")]
    public partial class ServiceSupplier : OrganisationRole, IModelObject
    {
        public ServiceSupplier(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Unique transaction reference prefix number issued to an entity by the International
        /// Organization for Standardization for the purpose of tagging onto electronic
        /// financial transactions, as defined in ISO/IEC 7812-1 and ISO/IEC 7812-2.
        /// </summary>
        public string issuerIdentificationNumber
        {
            get => ObjectData.GetAttribute<string>(nameof(issuerIdentificationNumber));
            set => ObjectData.SetAttribute<string>(nameof(issuerIdentificationNumber), value);
        }
         
        /// <summary>
        /// Kind of supplier.
        /// </summary>
        public SupplierKind kind
        {
            get => ObjectData.GetAttribute<SupplierKind>(nameof(kind));
            set => ObjectData.SetAttribute<SupplierKind>(nameof(kind), value);
        }
         
    }
     
    /// <summary>
    /// Simple end device function distinguished by 'kind'. Use this class for
    /// instances that cannot be represented by another end device function specialisations.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SimpleEndDeviceFunction")]
    public partial class SimpleEndDeviceFunction : EndDeviceFunction, IModelObject
    {
        public SimpleEndDeviceFunction(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Kind of this function.
        /// </summary>
        public EndDeviceFunctionKind kind
        {
            get => ObjectData.GetAttribute<EndDeviceFunctionKind>(nameof(kind));
            set => ObjectData.SetAttribute<EndDeviceFunctionKind>(nameof(kind), value);
        }
         
    }
     
    /// <summary>
    /// Current status information relevant to an entity.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Status")]
    public partial class Status : ModelObject, IModelObject
    {
        public Status(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date and time for which status 'value' applies.
        /// </summary>
        public object dateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(dateTime));
            set => ObjectData.SetAttribute<object>(nameof(dateTime), value);
        }
         
        /// <summary>
        /// Reason code or explanation for why an object went to the current status
        /// 'value'.
        /// </summary>
        public string reason
        {
            get => ObjectData.GetAttribute<string>(nameof(reason));
            set => ObjectData.SetAttribute<string>(nameof(reason), value);
        }
         
        /// <summary>
        /// Pertinent information regarding the current 'value', as free form text.
        /// </summary>
        public string remark
        {
            get => ObjectData.GetAttribute<string>(nameof(remark));
            set => ObjectData.SetAttribute<string>(nameof(remark), value);
        }
         
        /// <summary>
        /// Status value at 'dateTime'; prior status changes may have been kept in
        /// instances of activity records associated with the object to which this
        /// status applies.
        /// </summary>
        public string value
        {
            get => ObjectData.GetAttribute<string>(nameof(value));
            set => ObjectData.SetAttribute<string>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// Quantity with string value (when it is not important whether it is an integral
    /// or a floating point number) and associated unit information.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#StringQuantity")]
    public partial class StringQuantity : ModelObject, IModelObject
    {
        public StringQuantity(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Value of this quantity.
        /// </summary>
        public string value
        {
            get => ObjectData.GetAttribute<string>(nameof(value));
            set => ObjectData.SetAttribute<string>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// Interval between two times.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TimeInterval")]
    public partial class TimeInterval : ModelObject, IModelObject
    {
        public TimeInterval(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// End time of this interval.
        /// </summary>
        public object end
        {
            get => ObjectData.GetAttribute<object>(nameof(end));
            set => ObjectData.SetAttribute<object>(nameof(end), value);
        }
         
        /// <summary>
        /// Start time of this interval.
        /// </summary>
        public object start
        {
            get => ObjectData.GetAttribute<object>(nameof(start));
            set => ObjectData.SetAttribute<object>(nameof(start), value);
        }
         
    }
     
    /// <summary>
    /// Description of anything that changes through time. Time schedule is used
    /// to perform a single-valued function of time. Use inherited 'type' attribute
    /// to give additional information on this schedule, such as: periodic (hourly,
    /// daily, weekly, monthly, etc.), day of the month, by date, calendar (specific
    /// times and dates).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TimeSchedule")]
    public partial class TimeSchedule : Document, IModelObject
    {
        public TimeSchedule(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Schedule date and time interval.
        /// </summary>
        public DateTimeInterval scheduleInterval
        {
            get => ObjectData.GetAttribute<DateTimeInterval>(nameof(scheduleInterval));
            set => ObjectData.SetAttribute<DateTimeInterval>(nameof(scheduleInterval), value);
        }
         
    }
     
    /// <summary>
    /// Town details, in the context of address.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TownDetail")]
    public partial class TownDetail : ModelObject, IModelObject
    {
        public TownDetail(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Town code.
        /// </summary>
        public string code
        {
            get => ObjectData.GetAttribute<string>(nameof(code));
            set => ObjectData.SetAttribute<string>(nameof(code), value);
        }
         
        /// <summary>
        /// Name of the country.
        /// </summary>
        public string country
        {
            get => ObjectData.GetAttribute<string>(nameof(country));
            set => ObjectData.SetAttribute<string>(nameof(country), value);
        }
         
        /// <summary>
        /// Town name.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// Town section. For example, it is common for there to be 36 sections per
        /// township.
        /// </summary>
        public string section
        {
            get => ObjectData.GetAttribute<string>(nameof(section));
            set => ObjectData.SetAttribute<string>(nameof(section), value);
        }
         
        /// <summary>
        /// Name of the state or province.
        /// </summary>
        public string stateOrProvince
        {
            get => ObjectData.GetAttribute<string>(nameof(stateOrProvince));
            set => ObjectData.SetAttribute<string>(nameof(stateOrProvince), value);
        }
         
    }
     
    /// <summary>
    /// The derived units defined for usage in the CIM. In some cases, the derived
    /// unit is equal to an SI unit. Whenever possible, the standard derived symbol
    /// is used instead of the formula for the derived unit. For example, the unit
    /// symbol Farad is defined as "F" instead of "CPerV". In cases where a standard
    /// symbol does not exist for a derived unit, the formula for the unit is used
    /// as the unit symbol. For example, density does not have a standard symbol
    /// and so it is represented as "kgPerm3". With the exception of the "kg",
    /// which is an SI unit, the unit symbols do not contain multipliers and therefore
    /// represent the base derived unit to which a multiplier can be applied as
    /// a whole.
    /// Every unit symbol is treated as an unparseable text as if it were a single-letter
    /// symbol. The meaning of each unit symbol is defined by the accompanying
    /// descriptive text and not by the text contents of the unit symbol.
    /// To allow the widest possible range of serializations without requiring
    /// special character handling, several substitutions are made which deviate
    /// from the format described in IEC 80000-1. The division symbol "/" is replaced
    /// by the letters "Per". Exponents are written in plain text after the unit
    /// as "m3" instead of being formatted as "m" with a superscript of 3 or introducing
    /// a symbol as in "m^3". The degree symbol "" is replaced with the letters
    /// "deg". Any clarification of the meaning for a substitution is included
    /// in the description for the unit symbol.
    /// Non-SI units are included in list of unit symbols to allow sources of data
    /// to be correctly labelled with their non-SI units (for example, a GPS sensor
    /// that is reporting numbers that represent feet instead of meters). This
    /// allows software to use the unit symbol information correctly convert and
    /// scale the raw data of those sources into SI-based units.
    /// The integer values are used for harmonization with IEC 61850.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UnitSymbol")]
    public enum UnitSymbol
    {
        /// <summary>
        /// Frequency in hertz (1/s).
        /// </summary>
        Hz,
        /// <summary>
        /// Energy in joules (Nm = CV = Ws).
        /// </summary>
        J,
        /// <summary>
        /// Specific energy, Joules / kg.
        /// </summary>
        JPerkg,
        /// <summary>
        /// Apparent energy in volt ampere hours.
        /// </summary>
        VAh,
        /// <summary>
        /// Reactive power in volt amperes reactive. The reactive or imaginary
        /// component of electrical power (VIsin(phi)). (See also real power and apparent
        /// power).
        /// Note: Different meter designs use different methods to arrive at their
        /// results. Some meters may compute reactive power as an arithmetic value,
        /// while others compute the value vectorially. The data consumer should determine
        /// the method in use and the suitability of the measurement for the intended
        /// purpose.
        /// </summary>
        VAr,
        /// <summary>
        /// Reactive energy in volt ampere reactive hours.
        /// </summary>
        VArh,
        /// <summary>
        /// Volt-hour, Volt hours.
        /// </summary>
        Vh,
        /// <summary>
        /// Real energy in watt hours.
        /// </summary>
        Wh,
        /// <summary>
        /// Dimension less quantity, e.g. count, per unit, etc.
        /// </summary>
        none,
    }
     
    /// <summary>
    /// Logical or physical point in the network to which readings or events may
    /// be attributed. Used at the place where a physical or virtual meter may
    /// be located; however, it is not required that a meter be present.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UsagePoint")]
    public partial class UsagePoint : IdentifiedObject, IModelObject
    {
        public UsagePoint(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Tracks the lifecycle of the metering installation at a usage point with
        /// respect to readiness for billing via advanced metering infrastructure reads.
        /// </summary>
        public AmiBillingReadyKind amiBillingReady
        {
            get => ObjectData.GetAttribute<AmiBillingReadyKind>(nameof(amiBillingReady));
            set => ObjectData.SetAttribute<AmiBillingReadyKind>(nameof(amiBillingReady), value);
        }
         
        /// <summary>
        /// True if as a result of an inspection or otherwise, there is a reason to
        /// suspect that a previous billing may have been performed with erroneous
        /// data. Value should be reset once this potential discrepancy has been resolved.
        /// </summary>
        public bool checkBilling
        {
            get => ObjectData.GetAttribute<bool>(nameof(checkBilling));
            set => ObjectData.SetAttribute<bool>(nameof(checkBilling), value);
        }
         
        /// <summary>
        /// State of the usage point with respect to connection to the network.
        /// </summary>
        public UsagePointConnectedKind connectionState
        {
            get => ObjectData.GetAttribute<UsagePointConnectedKind>(nameof(connectionState));
            set => ObjectData.SetAttribute<UsagePointConnectedKind>(nameof(connectionState), value);
        }
         
        /// <summary>
        /// Estimated load.
        /// </summary>
        public float estimatedLoad
        {
            get => ObjectData.GetAttribute<float>(nameof(estimatedLoad));
            set => ObjectData.SetAttribute<float>(nameof(estimatedLoad), value);
        }
         
        /// <summary>
        /// True if grounded.
        /// </summary>
        public bool grounded
        {
            get => ObjectData.GetAttribute<bool>(nameof(grounded));
            set => ObjectData.SetAttribute<bool>(nameof(grounded), value);
        }
         
        /// <summary>
        /// If true, this usage point is a service delivery point, i.e., a usage point
        /// where the ownership of the service changes hands.
        /// </summary>
        public bool isSdp
        {
            get => ObjectData.GetAttribute<bool>(nameof(isSdp));
            set => ObjectData.SetAttribute<bool>(nameof(isSdp), value);
        }
         
        /// <summary>
        /// If true, this usage point is virtual, i.e., no physical location exists
        /// in the network where a meter could be located to collect the meter readings.
        /// For example, one may define a virtual usage point to serve as an aggregation
        /// of usage for all of a company's premises distributed widely across the
        /// distribution territory. Otherwise, the usage point is physical, i.e., there
        /// is a logical point in the network where a meter could be located to collect
        /// meter readings.
        /// </summary>
        public bool isVirtual
        {
            get => ObjectData.GetAttribute<bool>(nameof(isVirtual));
            set => ObjectData.SetAttribute<bool>(nameof(isVirtual), value);
        }
         
        /// <summary>
        /// If true, minimal or zero usage is expected at this usage point for situations
        /// such as premises vacancy, logical or physical disconnect. It is used for
        /// readings validation and estimation.
        /// </summary>
        public bool minimalUsageExpected
        {
            get => ObjectData.GetAttribute<bool>(nameof(minimalUsageExpected));
            set => ObjectData.SetAttribute<bool>(nameof(minimalUsageExpected), value);
        }
         
        /// <summary>
        /// Nominal service voltage.
        /// </summary>
        public float nominalServiceVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalServiceVoltage));
            set => ObjectData.SetAttribute<float>(nameof(nominalServiceVoltage), value);
        }
         
        /// <summary>
        /// Outage region in which this usage point is located.
        /// </summary>
        public string outageRegion
        {
            get => ObjectData.GetAttribute<string>(nameof(outageRegion));
            set => ObjectData.SetAttribute<string>(nameof(outageRegion), value);
        }
         
        /// <summary>
        /// Phase code. Number of wires and specific nominal phases can be deduced
        /// from enumeration literal values. For example, ABCN is three-phase, four-wire,
        /// s12n (splitSecondary12N) is single-phase, three-wire, and s1n and s2n are
        /// single-phase, two-wire.
        /// </summary>
        public PhaseCode phaseCode
        {
            get => ObjectData.GetAttribute<PhaseCode>(nameof(phaseCode));
            set => ObjectData.SetAttribute<PhaseCode>(nameof(phaseCode), value);
        }
         
        /// <summary>
        /// Current flow that this usage point is configured to deliver.
        /// </summary>
        public float ratedCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedCurrent));
            set => ObjectData.SetAttribute<float>(nameof(ratedCurrent), value);
        }
         
        /// <summary>
        /// Active power that this usage point is configured to deliver.
        /// </summary>
        public float ratedPower
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedPower));
            set => ObjectData.SetAttribute<float>(nameof(ratedPower), value);
        }
         
        /// <summary>
        /// Cycle day on which the meter for this usage point will normally be read.
        /// Usually correlated with the billing cycle.
        /// </summary>
        public string readCycle
        {
            get => ObjectData.GetAttribute<string>(nameof(readCycle));
            set => ObjectData.SetAttribute<string>(nameof(readCycle), value);
        }
         
        /// <summary>
        /// Identifier of the route to which this usage point is assigned for purposes
        /// of meter reading. Typically used to configure hand held meter reading systems
        /// prior to collection of reads.
        /// </summary>
        public string readRoute
        {
            get => ObjectData.GetAttribute<string>(nameof(readRoute));
            set => ObjectData.SetAttribute<string>(nameof(readRoute), value);
        }
         
        /// <summary>
        /// Remarks about this usage point, for example the reason for it being rated
        /// with a non-nominal priority.
        /// </summary>
        public string serviceDeliveryRemark
        {
            get => ObjectData.GetAttribute<string>(nameof(serviceDeliveryRemark));
            set => ObjectData.SetAttribute<string>(nameof(serviceDeliveryRemark), value);
        }
         
        /// <summary>
        /// Priority of service for this usage point. Note that usage points at the
        /// same service location can have different priorities.
        /// </summary>
        public string servicePriority
        {
            get => ObjectData.GetAttribute<string>(nameof(servicePriority));
            set => ObjectData.SetAttribute<string>(nameof(servicePriority), value);
        }
         
        /// <summary>
        /// All configuration events created for this usage point.
        /// </summary>
        public ConfigurationEvent[]? ConfigurationEvents
        {
            get => ObjectData.GetAssoc1ToM<ConfigurationEvent>(nameof(ConfigurationEvents));
        }
         
        public void AddToConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveFromConfigurationEvents(ConfigurationEvent value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConfigurationEvents), value);
        }
         
        public void RemoveAllFromConfigurationEvents()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConfigurationEvents));
        }
         
        /// <summary>
        /// Customer agreement regulating this service delivery point.
        /// </summary>
        public CustomerAgreement? CustomerAgreement
        {
            get => ObjectData.GetAssoc1To1<CustomerAgreement>(nameof(CustomerAgreement));
            set => ObjectData.SetAssoc1To1(nameof(CustomerAgreement), value);
        }
         
        /// <summary>
        /// All end devices at this usage point.
        /// </summary>
        public EndDevice[]? EndDevices
        {
            get => ObjectData.GetAssoc1ToM<EndDevice>(nameof(EndDevices));
        }
         
        public void AddToEndDevices(EndDevice value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveFromEndDevices(EndDevice value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveAllFromEndDevices()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDevices));
        }
         
        /// <summary>
        /// All equipment connecting this usage point to the electrical grid.
        /// </summary>
        public Equipment[]? Equipments
        {
            get => ObjectData.GetAssoc1ToM<Equipment>(nameof(Equipments));
        }
         
        public void AddToEquipments(Equipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveFromEquipments(Equipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveAllFromEquipments()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Equipments));
        }
         
        /// <summary>
        /// All metrology requirements for this usage point.
        /// </summary>
        public MetrologyRequirement[]? MetrologyRequirements
        {
            get => ObjectData.GetAssoc1ToM<MetrologyRequirement>(nameof(MetrologyRequirements));
        }
         
        public void AddToMetrologyRequirements(MetrologyRequirement value)
        {
            ObjectData.AddAssoc1ToM(nameof(MetrologyRequirements), value);
        }
         
        public void RemoveFromMetrologyRequirements(MetrologyRequirement value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(MetrologyRequirements), value);
        }
         
        public void RemoveAllFromMetrologyRequirements()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(MetrologyRequirements));
        }
         
        /// <summary>
        /// All pricing structures applicable to this service delivery point (with
        /// prepayment meter running as a stand-alone device, with no CustomerAgreement
        /// or Customer).
        /// </summary>
        public PricingStructure[]? PricingStructures
        {
            get => ObjectData.GetAssoc1ToM<PricingStructure>(nameof(PricingStructures));
        }
         
        public void AddToPricingStructures(PricingStructure value)
        {
            ObjectData.AddAssoc1ToM(nameof(PricingStructures), value);
        }
         
        public void RemoveFromPricingStructures(PricingStructure value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PricingStructures), value);
        }
         
        public void RemoveAllFromPricingStructures()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PricingStructures));
        }
         
        /// <summary>
        /// Service category delivered by this usage point.
        /// </summary>
        public ServiceCategory? ServiceCategory
        {
            get => ObjectData.GetAssoc1To1<ServiceCategory>(nameof(ServiceCategory));
            set => ObjectData.SetAssoc1To1(nameof(ServiceCategory), value);
        }
         
        /// <summary>
        /// Service location where the service delivered by this usage point is consumed.
        /// </summary>
        public ServiceLocation? ServiceLocation
        {
            get => ObjectData.GetAssoc1To1<ServiceLocation>(nameof(ServiceLocation));
            set => ObjectData.SetAssoc1To1(nameof(ServiceLocation), value);
        }
         
        /// <summary>
        /// All multipliers applied at this usage point.
        /// </summary>
        public ServiceMultiplier[]? ServiceMultipliers
        {
            get => ObjectData.GetAssoc1ToM<ServiceMultiplier>(nameof(ServiceMultipliers));
        }
         
        public void AddToServiceMultipliers(ServiceMultiplier value)
        {
            ObjectData.AddAssoc1ToM(nameof(ServiceMultipliers), value);
        }
         
        public void RemoveFromServiceMultipliers(ServiceMultiplier value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ServiceMultipliers), value);
        }
         
        public void RemoveAllFromServiceMultipliers()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ServiceMultipliers));
        }
         
        /// <summary>
        /// ServiceSupplier (utility) utilising this usage point to deliver a service.
        /// </summary>
        public ServiceSupplier? ServiceSupplier
        {
            get => ObjectData.GetAssoc1To1<ServiceSupplier>(nameof(ServiceSupplier));
            set => ObjectData.SetAssoc1To1(nameof(ServiceSupplier), value);
        }
         
        /// <summary>
        /// Location of this usage point.
        /// </summary>
        public UsagePointLocation? UsagePointLocation
        {
            get => ObjectData.GetAssoc1To1<UsagePointLocation>(nameof(UsagePointLocation));
            set => ObjectData.SetAssoc1To1(nameof(UsagePointLocation), value);
        }
         
    }
     
    /// <summary>
    /// State of the usage point with respect to connection to the network.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UsagePointConnectedKind")]
    public enum UsagePointConnectedKind
    {
        /// <summary>
        /// The usage point is connected to the network and able to receive or send
        /// the applicable commodity (electricity, gas, water, etc.).
        /// </summary>
        connected,
        /// <summary>
        /// The usage point has been disconnected through operation of a disconnect
        /// function within the meter present at the usage point. The usage point is
        /// unable to receive or send the applicable commodity (electricity, gas, water,
        /// etc.) A logical disconnect can often be achieved without utilising a field
        /// crew.
        /// </summary>
        logicallyDisconnected,
        /// <summary>
        /// The usage point has been disconnected from the network at a point upstream
        /// of the meter. The usage point is unable to receive or send the applicable
        /// commodity (electricity, gas, water, etc.). A physical disconnect is often
        /// achieved by utilising a field crew.
        /// </summary>
        physicallyDisconnected,
    }
     
    /// <summary>
    /// Location of an individual usage point.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UsagePointLocation")]
    public partial class UsagePointLocation : Location, IModelObject
    {
        public UsagePointLocation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Method for the service person to access this usage point location. For
        /// example, a description of where to obtain a key if the facility is unmanned
        /// and secured.
        /// </summary>
        public string accessMethod
        {
            get => ObjectData.GetAttribute<string>(nameof(accessMethod));
            set => ObjectData.SetAttribute<string>(nameof(accessMethod), value);
        }
         
        /// <summary>
        /// Remarks about this location.
        /// </summary>
        public string remark
        {
            get => ObjectData.GetAttribute<string>(nameof(remark));
            set => ObjectData.SetAttribute<string>(nameof(remark), value);
        }
         
        /// <summary>
        /// Problems previously encountered when visiting or performing work at this
        /// location. Examples include: bad dog, violent customer, verbally abusive
        /// occupant, obstructions, safety hazards, etc.
        /// </summary>
        public string siteAccessProblem
        {
            get => ObjectData.GetAttribute<string>(nameof(siteAccessProblem));
            set => ObjectData.SetAttribute<string>(nameof(siteAccessProblem), value);
        }
         
        /// <summary>
        /// All usage points at this location.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// Generic name-value pair class, with optional sequence number and units
    /// for value; can be used to model parts of information exchange when concrete
    /// types are not known in advance.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UserAttribute")]
    public partial class UserAttribute : ModelObject, IModelObject
    {
        public UserAttribute(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Name of an attribute.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// Sequence number for this attribute in a list of attributes.
        /// </summary>
        public int sequenceNumber
        {
            get => ObjectData.GetAttribute<int>(nameof(sequenceNumber));
            set => ObjectData.SetAttribute<int>(nameof(sequenceNumber), value);
        }
         
        /// <summary>
        /// Value of an attribute, including unit information.
        /// </summary>
        public StringQuantity value
        {
            get => ObjectData.GetAttribute<StringQuantity>(nameof(value));
            set => ObjectData.SetAttribute<StringQuantity>(nameof(value), value);
        }
         
    }
     
}
