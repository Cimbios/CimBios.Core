using CimBios.Core.CimModel.CimDatatypeLib;
/**
 * Annotated C# for Profile
 * Generated by CIMTool http://cimtool.org
 */
namespace Profile
{
    /// <summary>
    /// Limit on active power flow.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ActivePowerLimit")]
    public partial class ActivePowerLimit : ModelObject, IModelObject
    {
        public ActivePowerLimit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The normal value of active power limit. The attribute shall be a positive
        /// value or zero.
        /// </summary>
        public float normalValue
        {
            get => ObjectData.GetAttribute<float>(nameof(normalValue));
            set => ObjectData.SetAttribute<float>(nameof(normalValue), value);
        }
         
        /// <summary>
        /// Value of active power limit. The attribute shall be a positive value or
        /// zero.
        /// </summary>
        public float value
        {
            get => ObjectData.GetAttribute<float>(nameof(value));
            set => ObjectData.SetAttribute<float>(nameof(value), value);
        }
         
    }
     
    /// <summary>
    /// A rotating machine whose shaft rotates asynchronously with the electrical
    /// field. Also known as an induction machine with no external connection to
    /// the rotor windings, e.g. squirrel-cage induction machine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AsynchronousMachine")]
    public partial class AsynchronousMachine : RotatingMachine, IModelObject
    {
        public AsynchronousMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Indicates the type of Asynchronous Machine (motor or generator).
        /// </summary>
        public AsynchronousMachineKind asynchronousMachineType
        {
            get => ObjectData.GetAttribute<AsynchronousMachineKind>(nameof(asynchronousMachineType));
            set => ObjectData.SetAttribute<AsynchronousMachineKind>(nameof(asynchronousMachineType), value);
        }
         
        /// <summary>
        /// Efficiency of the asynchronous machine at nominal operation as a percentage.
        /// Indicator for converter drive motors. Used for short circuit data exchange
        /// according to IEC 60909.
        /// </summary>
        public float efficiency
        {
            get => ObjectData.GetAttribute<float>(nameof(efficiency));
            set => ObjectData.SetAttribute<float>(nameof(efficiency), value);
        }
         
        /// <summary>
        /// Rated mechanical power (Pr in IEC 60909-0). Used for short circuit data
        /// exchange according to IEC 60909.
        /// </summary>
        public float ratedMechanicalPower
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedMechanicalPower));
            set => ObjectData.SetAttribute<float>(nameof(ratedMechanicalPower), value);
        }
         
        /// <summary>
        /// </summary>
        public AsynchronousMachineReactiveCapabilityCurve? ReactiveCapabilityCurve
        {
            get => ObjectData.GetAssoc1To1<AsynchronousMachineReactiveCapabilityCurve>(nameof(ReactiveCapabilityCurve));
            set => ObjectData.SetAssoc1To1(nameof(ReactiveCapabilityCurve), value);
        }
         
        /// <summary>
        /// </summary>
        public TorqueSpeedCurve? TorqueSpeedCurve
        {
            get => ObjectData.GetAssoc1To1<TorqueSpeedCurve>(nameof(TorqueSpeedCurve));
            set => ObjectData.SetAssoc1To1(nameof(TorqueSpeedCurve), value);
        }
         
    }
     
    /// <summary>
    /// Kind of Asynchronous Machine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AsynchronousMachineKind")]
    public enum AsynchronousMachineKind
    {
        /// <summary>
        /// The Asynchronous Machine is a generator.
        /// </summary>
        generator,
        /// <summary>
        /// </summary>
        generatorOrMotor,
        /// <summary>
        /// The Asynchronous Machine is a motor.
        /// </summary>
        motor,
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#AsynchronousMachineReactiveCapabilityCurve")]
    public partial class AsynchronousMachineReactiveCapabilityCurve : ModelObject, IModelObject
    {
        public AsynchronousMachineReactiveCapabilityCurve(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public AsynchronousMachine[]? AsynchronousMachine
        {
            get => ObjectData.GetAssoc1ToM<AsynchronousMachine>(nameof(AsynchronousMachine));
        }
         
        public void AddToAsynchronousMachine(AsynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(AsynchronousMachine), value);
        }
         
        public void RemoveFromAsynchronousMachine(AsynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AsynchronousMachine), value);
        }
         
        public void RemoveAllFromAsynchronousMachine()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AsynchronousMachine));
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#AsynchronousMachinelnfo")]
    public partial class AsynchronousMachinelnfo : RotatingMachineInfo, IModelObject
    {
        public AsynchronousMachinelnfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float maxTorque
        {
            get => ObjectData.GetAttribute<float>(nameof(maxTorque));
            set => ObjectData.SetAttribute<float>(nameof(maxTorque), value);
        }
         
        /// <summary>
        /// </summary>
        public float startCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(startCurrent));
            set => ObjectData.SetAttribute<float>(nameof(startCurrent), value);
        }
         
        /// <summary>
        /// </summary>
        public float startingTorque
        {
            get => ObjectData.GetAttribute<float>(nameof(startingTorque));
            set => ObjectData.SetAttribute<float>(nameof(startingTorque), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#BrushlessExciterlnfo")]
    public partial class BrushlessExciterlnfo : ModelObject, IModelObject
    {
        public BrushlessExciterlnfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float deexcitationRatio
        {
            get => ObjectData.GetAttribute<float>(nameof(deexcitationRatio));
            set => ObjectData.SetAttribute<float>(nameof(deexcitationRatio), value);
        }
         
        /// <summary>
        /// </summary>
        public float forcingRatio
        {
            get => ObjectData.GetAttribute<float>(nameof(forcingRatio));
            set => ObjectData.SetAttribute<float>(nameof(forcingRatio), value);
        }
         
        /// <summary>
        /// </summary>
        public float nominalP
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalP));
            set => ObjectData.SetAttribute<float>(nameof(nominalP), value);
        }
         
        /// <summary>
        /// </summary>
        public float rAdditionalResistor
        {
            get => ObjectData.GetAttribute<float>(nameof(rAdditionalResistor));
            set => ObjectData.SetAttribute<float>(nameof(rAdditionalResistor), value);
        }
         
        /// <summary>
        /// </summary>
        public float ratedCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedCurrent));
            set => ObjectData.SetAttribute<float>(nameof(ratedCurrent), value);
        }
         
        /// <summary>
        /// </summary>
        public float ratedVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedVoltage));
            set => ObjectData.SetAttribute<float>(nameof(ratedVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float rExcitationWinding
        {
            get => ObjectData.GetAttribute<float>(nameof(rExcitationWinding));
            set => ObjectData.SetAttribute<float>(nameof(rExcitationWinding), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotorResistance
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorResistance));
            set => ObjectData.SetAttribute<float>(nameof(rotorResistance), value);
        }
         
        /// <summary>
        /// </summary>
        public float td
        {
            get => ObjectData.GetAttribute<float>(nameof(td));
            set => ObjectData.SetAttribute<float>(nameof(td), value);
        }
         
        /// <summary>
        /// </summary>
        public float xDirectSubtrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectSubtrans));
            set => ObjectData.SetAttribute<float>(nameof(xDirectSubtrans), value);
        }
         
        /// <summary>
        /// </summary>
        public float xDirectSync
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectSync));
            set => ObjectData.SetAttribute<float>(nameof(xDirectSync), value);
        }
         
        /// <summary>
        /// </summary>
        public float xDirectTrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectTrans));
            set => ObjectData.SetAttribute<float>(nameof(xDirectTrans), value);
        }
         
        /// <summary>
        /// </summary>
        public float xQuadSubtrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xQuadSubtrans));
            set => ObjectData.SetAttribute<float>(nameof(xQuadSubtrans), value);
        }
         
        /// <summary>
        /// </summary>
        public float xQuadSync
        {
            get => ObjectData.GetAttribute<float>(nameof(xQuadSync));
            set => ObjectData.SetAttribute<float>(nameof(xQuadSync), value);
        }
         
        /// <summary>
        /// </summary>
        public float xs
        {
            get => ObjectData.GetAttribute<float>(nameof(xs));
            set => ObjectData.SetAttribute<float>(nameof(xs), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#CapacityConfiguration")]
    public partial class CapacityConfiguration : ModelObject, IModelObject
    {
        public CapacityConfiguration(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float maximumCapacity
        {
            get => ObjectData.GetAttribute<float>(nameof(maximumCapacity));
            set => ObjectData.SetAttribute<float>(nameof(maximumCapacity), value);
        }
         
        /// <summary>
        /// </summary>
        public CombinedCyclePlant? CombinedCyclePlant
        {
            get => ObjectData.GetAssoc1To1<CombinedCyclePlant>(nameof(CombinedCyclePlant));
            set => ObjectData.SetAssoc1To1(nameof(CombinedCyclePlant), value);
        }
         
        /// <summary>
        /// </summary>
        public ThermalGeneratingUnit[]? ThermalGeneratingUnits
        {
            get => ObjectData.GetAssoc1ToM<ThermalGeneratingUnit>(nameof(ThermalGeneratingUnits));
        }
         
        public void AddToThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.AddAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveFromThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveAllFromThermalGeneratingUnits()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ThermalGeneratingUnits));
        }
         
    }
     
    /// <summary>
    /// A set of thermal generating units for the production of electrical energy
    /// and process steam (usually from the output of the steam turbines). The
    /// steam sendout is typically used for industrial purposes or for municipal
    /// heating and cooling.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CogenerationPlant")]
    public partial class CogenerationPlant : ModelObject, IModelObject
    {
        public CogenerationPlant(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The rated output active power of the cogeneration plant.
        /// The attribute shall be a positive value.
        /// </summary>
        public float ratedP
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedP));
            set => ObjectData.SetAttribute<float>(nameof(ratedP), value);
        }
         
        /// <summary>
        /// A thermal generating unit may be a member of a cogeneration plant.
        /// </summary>
        public ThermalGeneratingUnit[]? ThermalGeneratingUnits
        {
            get => ObjectData.GetAssoc1ToM<ThermalGeneratingUnit>(nameof(ThermalGeneratingUnits));
        }
         
        public void AddToThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.AddAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveFromThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveAllFromThermalGeneratingUnits()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ThermalGeneratingUnits));
        }
         
    }
     
    /// <summary>
    /// A set of combustion turbines and steam turbines where the exhaust heat
    /// from the combustion turbines is recovered to make steam for the steam turbines,
    /// resulting in greater overall plant efficiency.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CombinedCyclePlant")]
    public partial class CombinedCyclePlant : ModelObject, IModelObject
    {
        public CombinedCyclePlant(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The combined cycle plant's active power output rating.
        /// </summary>
        public float combCyclePlantRating
        {
            get => ObjectData.GetAttribute<float>(nameof(combCyclePlantRating));
            set => ObjectData.SetAttribute<float>(nameof(combCyclePlantRating), value);
        }
         
        /// <summary>
        /// A thermal generating unit may be a member of a combined cycle plant.
        /// </summary>
        public ThermalGeneratingUnit[]? ThermalGeneratingUnits
        {
            get => ObjectData.GetAssoc1ToM<ThermalGeneratingUnit>(nameof(ThermalGeneratingUnits));
        }
         
        public void AddToThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.AddAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveFromThermalGeneratingUnits(ThermalGeneratingUnit value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ThermalGeneratingUnits), value);
        }
         
        public void RemoveAllFromThermalGeneratingUnits()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ThermalGeneratingUnits));
        }
         
    }
     
    /// <summary>
    /// Method of cooling a machine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CoolantType")]
    public enum CoolantType
    {
        /// <summary>
        /// Air.
        /// </summary>
        air,
        /// <summary>
        /// Hydrogen gas.
        /// </summary>
        hydrogenGas,
        /// <summary>
        /// Water.
        /// </summary>
        water,
    }
     
    /// <summary>
    /// Abstract parent class for all Dynamics function blocks.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DynamicsFunctionBlock")]
    public partial class DynamicsFunctionBlock : ModelObject, IModelObject
    {
        public DynamicsFunctionBlock(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#ExcitationControl")]
    public partial class ExcitationControl : ModelObject, IModelObject
    {
        public ExcitationControl(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public string stabilizerType
        {
            get => ObjectData.GetAttribute<string>(nameof(stabilizerType));
            set => ObjectData.SetAttribute<string>(nameof(stabilizerType), value);
        }
         
        /// <summary>
        /// </summary>
        public string voltageControlType
        {
            get => ObjectData.GetAttribute<string>(nameof(voltageControlType));
            set => ObjectData.SetAttribute<string>(nameof(voltageControlType), value);
        }
         
        /// <summary>
        /// </summary>
        public ExcitationSystem? ExcitationSystem
        {
            get => ObjectData.GetAssoc1To1<ExcitationSystem>(nameof(ExcitationSystem));
            set => ObjectData.SetAssoc1To1(nameof(ExcitationSystem), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#ExcitationControllnfo")]
    public partial class ExcitationControllnfo : ModelObject, IModelObject
    {
        public ExcitationControllnfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public string algorithmVersion
        {
            get => ObjectData.GetAttribute<string>(nameof(algorithmVersion));
            set => ObjectData.SetAttribute<string>(nameof(algorithmVersion), value);
        }
         
        /// <summary>
        /// </summary>
        public float currentGainFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(currentGainFactor));
            set => ObjectData.SetAttribute<float>(nameof(currentGainFactor), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyGainFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyGainFactor));
            set => ObjectData.SetAttribute<float>(nameof(frequencyGainFactor), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(frequencyGainFactorDerivative), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyMaxGainFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyMaxGainFactor));
            set => ObjectData.SetAttribute<float>(nameof(frequencyMaxGainFactor), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyMaxGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyMaxGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(frequencyMaxGainFactorDerivative), value);
        }
         
        /// <summary>
        /// </summary>
        public float piTimeConstant
        {
            get => ObjectData.GetAttribute<float>(nameof(piTimeConstant));
            set => ObjectData.SetAttribute<float>(nameof(piTimeConstant), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotorCurrentGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorCurrentGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(rotorCurrentGainFactorDerivative), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotorCurrentMaxGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorCurrentMaxGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(rotorCurrentMaxGainFactorDerivative), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageGainFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageGainFactor));
            set => ObjectData.SetAttribute<float>(nameof(voltageGainFactor), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(voltageGainFactorDerivative), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageMaxGainFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageMaxGainFactor));
            set => ObjectData.SetAttribute<float>(nameof(voltageMaxGainFactor), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageMaxGainFactorDerivative
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageMaxGainFactorDerivative));
            set => ObjectData.SetAttribute<float>(nameof(voltageMaxGainFactorDerivative), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#ExcitationSystem")]
    public partial class ExcitationSystem : ModelObject, IModelObject
    {
        public ExcitationSystem(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float currentExcitationForcingRatio
        {
            get => ObjectData.GetAttribute<float>(nameof(currentExcitationForcingRatio));
            set => ObjectData.SetAttribute<float>(nameof(currentExcitationForcingRatio), value);
        }
         
        /// <summary>
        /// </summary>
        public float excitationForcingDelay
        {
            get => ObjectData.GetAttribute<float>(nameof(excitationForcingDelay));
            set => ObjectData.SetAttribute<float>(nameof(excitationForcingDelay), value);
        }
         
        /// <summary>
        /// </summary>
        public float excitationForcingDuration
        {
            get => ObjectData.GetAttribute<float>(nameof(excitationForcingDuration));
            set => ObjectData.SetAttribute<float>(nameof(excitationForcingDuration), value);
        }
         
        /// <summary>
        /// </summary>
        public float excitationForcingRapidity
        {
            get => ObjectData.GetAttribute<float>(nameof(excitationForcingRapidity));
            set => ObjectData.SetAttribute<float>(nameof(excitationForcingRapidity), value);
        }
         
        /// <summary>
        /// </summary>
        public float fullDeexcitationTime
        {
            get => ObjectData.GetAttribute<float>(nameof(fullDeexcitationTime));
            set => ObjectData.SetAttribute<float>(nameof(fullDeexcitationTime), value);
        }
         
        /// <summary>
        /// </summary>
        public float maxDoubleOverloadTime
        {
            get => ObjectData.GetAttribute<float>(nameof(maxDoubleOverloadTime));
            set => ObjectData.SetAttribute<float>(nameof(maxDoubleOverloadTime), value);
        }
         
        /// <summary>
        /// </summary>
        public float relayExcitationReleaseDelay
        {
            get => ObjectData.GetAttribute<float>(nameof(relayExcitationReleaseDelay));
            set => ObjectData.SetAttribute<float>(nameof(relayExcitationReleaseDelay), value);
        }
         
        /// <summary>
        /// </summary>
        public float relayExcitationReleaseVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(relayExcitationReleaseVoltage));
            set => ObjectData.SetAttribute<float>(nameof(relayExcitationReleaseVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float relayExcitationTriggerVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(relayExcitationTriggerVoltage));
            set => ObjectData.SetAttribute<float>(nameof(relayExcitationTriggerVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotorGD2
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorGD2));
            set => ObjectData.SetAttribute<float>(nameof(rotorGD2), value);
        }
         
        /// <summary>
        /// </summary>
        public float timeConstant
        {
            get => ObjectData.GetAttribute<float>(nameof(timeConstant));
            set => ObjectData.SetAttribute<float>(nameof(timeConstant), value);
        }
         
        /// <summary>
        /// </summary>
        public float timeDoubleCurrentOverload
        {
            get => ObjectData.GetAttribute<float>(nameof(timeDoubleCurrentOverload));
            set => ObjectData.SetAttribute<float>(nameof(timeDoubleCurrentOverload), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageDeexcitationRatio
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageDeexcitationRatio));
            set => ObjectData.SetAttribute<float>(nameof(voltageDeexcitationRatio), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageExcitationForcingRatio
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageExcitationForcingRatio));
            set => ObjectData.SetAttribute<float>(nameof(voltageExcitationForcingRatio), value);
        }
         
        /// <summary>
        /// </summary>
        public float voltageExcitationRampRate
        {
            get => ObjectData.GetAttribute<float>(nameof(voltageExcitationRampRate));
            set => ObjectData.SetAttribute<float>(nameof(voltageExcitationRampRate), value);
        }
         
        /// <summary>
        /// </summary>
        public ExcitationControl? ExcitationControl
        {
            get => ObjectData.GetAssoc1To1<ExcitationControl>(nameof(ExcitationControl));
            set => ObjectData.SetAssoc1To1(nameof(ExcitationControl), value);
        }
         
        /// <summary>
        /// </summary>
        public SynchronousMachine[]? SynchronousMachine
        {
            get => ObjectData.GetAssoc1ToM<SynchronousMachine>(nameof(SynchronousMachine));
        }
         
        public void AddToSynchronousMachine(SynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(SynchronousMachine), value);
        }
         
        public void RemoveFromSynchronousMachine(SynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(SynchronousMachine), value);
        }
         
        public void RemoveAllFromSynchronousMachine()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(SynchronousMachine));
        }
         
    }
     
    /// <summary>
    /// The fossil fuel consumed by the non-nuclear thermal generating unit. For
    /// example, coal, oil, gas, etc. These are the specific fuels that the generating
    /// unit can consume.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#FossilFuel")]
    public partial class FossilFuel : ModelObject, IModelObject
    {
        public FossilFuel(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The type of fossil fuel, such as coal, oil, or gas.
        /// </summary>
        public FuelType fossilFuelType
        {
            get => ObjectData.GetAttribute<FuelType>(nameof(fossilFuelType));
            set => ObjectData.SetAttribute<FuelType>(nameof(fossilFuelType), value);
        }
         
        /// <summary>
        /// The efficiency factor for the fuel (per unit) in terms of the effective
        /// energy absorbed.
        /// </summary>
        public float fuelEffFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(fuelEffFactor));
            set => ObjectData.SetAttribute<float>(nameof(fuelEffFactor), value);
        }
         
        /// <summary>
        /// The amount of heat per weight (or volume) of the given type of fuel.
        /// </summary>
        public float fuelHeatContent
        {
            get => ObjectData.GetAttribute<float>(nameof(fuelHeatContent));
            set => ObjectData.SetAttribute<float>(nameof(fuelHeatContent), value);
        }
         
        /// <summary>
        /// A thermal generating unit may have one or more fossil fuels.
        /// </summary>
        public ThermalGeneratingUnit? ThermalGeneratingUnit
        {
            get => ObjectData.GetAssoc1To1<ThermalGeneratingUnit>(nameof(ThermalGeneratingUnit));
            set => ObjectData.SetAssoc1To1(nameof(ThermalGeneratingUnit), value);
        }
         
    }
     
    /// <summary>
    /// Type of fuel.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#FuelType")]
    public enum FuelType
    {
        /// <summary>
        /// Generic coal, not including lignite type.
        /// </summary>
        coal,
        /// <summary>
        /// Natural gas.
        /// </summary>
        gas,
        /// <summary>
        /// Hard coal.
        /// </summary>
        hardCoal,
        /// <summary>
        /// The fuel is lignite coal. Note that this is a special type of coal, so
        /// the other enum of coal is reserved for hard coal types or if the exact
        /// type of coal is not known.
        /// </summary>
        lignite,
        /// <summary>
        /// Oil.
        /// </summary>
        oil,
        /// <summary>
        /// Oil Shale.
        /// </summary>
        oilShale,
        /// <summary>
        /// Any fuel type not included in the rest of the enumerated value.
        /// </summary>
        other,
        /// <summary>
        /// Peat.
        /// </summary>
        peat,
    }
     
    /// <summary>
    /// A single or set of synchronous machines for converting mechanical power
    /// into alternating-current power. For example, individual machines within
    /// a set may be defined for scheduling purposes while a single control signal
    /// is derived for the set. In this case there would be a GeneratingUnit for
    /// each member of the set and an additional GeneratingUnit corresponding to
    /// the set.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#GeneratingUnit")]
    public partial class GeneratingUnit : ModelObject, IModelObject
    {
        public GeneratingUnit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Governor Speed Changer Droop. This is the change in generator power output
        /// divided by the change in frequency normalized by the nominal power of the
        /// generator and the nominal frequency and expressed in percent and negated.
        /// A positive value of speed change droop provides additional generator output
        /// upon a drop in frequency.
        /// </summary>
        public float governorSCD
        {
            get => ObjectData.GetAttribute<float>(nameof(governorSCD));
            set => ObjectData.SetAttribute<float>(nameof(governorSCD), value);
        }
         
        /// <summary>
        /// High limit for secondary (AGC) control.
        /// </summary>
        public float highControlLimit
        {
            get => ObjectData.GetAttribute<float>(nameof(highControlLimit));
            set => ObjectData.SetAttribute<float>(nameof(highControlLimit), value);
        }
         
        /// <summary>
        /// Low limit for secondary (AGC) control.
        /// </summary>
        public float lowControlLimit
        {
            get => ObjectData.GetAttribute<float>(nameof(lowControlLimit));
            set => ObjectData.SetAttribute<float>(nameof(lowControlLimit), value);
        }
         
        /// <summary>
        /// The normal maximum rate the generating unit active power output can be
        /// lowered by control actions.
        /// </summary>
        public float lowerRampRate
        {
            get => ObjectData.GetAttribute<float>(nameof(lowerRampRate));
            set => ObjectData.SetAttribute<float>(nameof(lowerRampRate), value);
        }
         
        /// <summary>
        /// This is the maximum operating active power limit the dispatcher can enter
        /// for this unit.
        /// </summary>
        public float maxOperatingP
        {
            get => ObjectData.GetAttribute<float>(nameof(maxOperatingP));
            set => ObjectData.SetAttribute<float>(nameof(maxOperatingP), value);
        }
         
        /// <summary>
        /// This is the minimum operating active power limit the dispatcher can enter
        /// for this unit.
        /// </summary>
        public float minOperatingP
        {
            get => ObjectData.GetAttribute<float>(nameof(minOperatingP));
            set => ObjectData.SetAttribute<float>(nameof(minOperatingP), value);
        }
         
        /// <summary>
        /// The nominal power of the generating unit. Used to give precise meaning
        /// to percentage based attributes such as the governor speed change droop
        /// (governorSCD attribute).
        /// The attribute shall be a positive value equal to or less than RotatingMachine.ratedS.
        /// </summary>
        public float nominalP
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalP));
            set => ObjectData.SetAttribute<float>(nameof(nominalP), value);
        }
         
        /// <summary>
        /// The normal maximum rate the generating unit active power output can be
        /// raised by control actions.
        /// </summary>
        public float raiseRampRate
        {
            get => ObjectData.GetAttribute<float>(nameof(raiseRampRate));
            set => ObjectData.SetAttribute<float>(nameof(raiseRampRate), value);
        }
         
        /// <summary>
        /// </summary>
        public float unitGD2
        {
            get => ObjectData.GetAttribute<float>(nameof(unitGD2));
            set => ObjectData.SetAttribute<float>(nameof(unitGD2), value);
        }
         
    }
     
    /// <summary>
    /// Specifies the capability of the hydro generating unit to convert energy
    /// as a generator or pump.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroEnergyConversionKind")]
    public enum HydroEnergyConversionKind
    {
        /// <summary>
        /// Able to generate power, but not able to pump water for energy storage.
        /// </summary>
        generator,
        /// <summary>
        /// Able to both generate power and pump water for energy storage.
        /// </summary>
        pumpAndGenerator,
    }
     
    /// <summary>
    /// A generating unit whose prime mover is a hydraulic turbine (e.g., Francis,
    /// Pelton, Kaplan).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroGeneratingUnit")]
    public partial class HydroGeneratingUnit : GeneratingUnit, IModelObject
    {
        public HydroGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Energy conversion capability for generating.
        /// </summary>
        public HydroEnergyConversionKind energyConversionCapability
        {
            get => ObjectData.GetAttribute<HydroEnergyConversionKind>(nameof(energyConversionCapability));
            set => ObjectData.SetAttribute<HydroEnergyConversionKind>(nameof(energyConversionCapability), value);
        }
         
        /// <summary>
        /// </summary>
        public float normaIWaterLevel
        {
            get => ObjectData.GetAttribute<float>(nameof(normaIWaterLevel));
            set => ObjectData.SetAttribute<float>(nameof(normaIWaterLevel), value);
        }
         
        /// <summary>
        /// </summary>
        public float normalWaterFlow
        {
            get => ObjectData.GetAttribute<float>(nameof(normalWaterFlow));
            set => ObjectData.SetAttribute<float>(nameof(normalWaterFlow), value);
        }
         
        /// <summary>
        /// The hydro generating unit belongs to a hydro power plant.
        /// </summary>
        public HydroPowerPlant? HydroPowerPlant
        {
            get => ObjectData.GetAssoc1To1<HydroPowerPlant>(nameof(HydroPowerPlant));
            set => ObjectData.SetAssoc1To1(nameof(HydroPowerPlant), value);
        }
         
    }
     
    /// <summary>
    /// The type of hydro power plant.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroPlantStorageKind")]
    public enum HydroPlantStorageKind
    {
        /// <summary>
        /// Pumped storage.
        /// </summary>
        pumpedStorage,
        /// <summary>
        /// Run of river.
        /// </summary>
        runOfRiver,
        /// <summary>
        /// Storage.
        /// </summary>
        storage,
    }
     
    /// <summary>
    /// A hydro power station which can generate or pump. When generating, the
    /// generator turbines receive water from an upper reservoir. When pumping,
    /// the pumps receive their water from a lower reservoir.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroPowerPlant")]
    public partial class HydroPowerPlant : ModelObject, IModelObject
    {
        public HydroPowerPlant(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The hydro plant's generating rating active power for rated head conditions.
        /// The attribute shall be a positive value.
        /// </summary>
        public float genRatedP
        {
            get => ObjectData.GetAttribute<float>(nameof(genRatedP));
            set => ObjectData.SetAttribute<float>(nameof(genRatedP), value);
        }
         
        /// <summary>
        /// The type of hydro power plant water storage.
        /// </summary>
        public HydroPlantStorageKind hydroPlantStorageType
        {
            get => ObjectData.GetAttribute<HydroPlantStorageKind>(nameof(hydroPlantStorageType));
            set => ObjectData.SetAttribute<HydroPlantStorageKind>(nameof(hydroPlantStorageType), value);
        }
         
        /// <summary>
        /// The hydro generating unit belongs to a hydro power plant.
        /// </summary>
        public HydroGeneratingUnit[]? HydroGeneratingUnits
        {
            get => ObjectData.GetAssoc1ToM<HydroGeneratingUnit>(nameof(HydroGeneratingUnits));
        }
         
        public void AddToHydroGeneratingUnits(HydroGeneratingUnit value)
        {
            ObjectData.AddAssoc1ToM(nameof(HydroGeneratingUnits), value);
        }
         
        public void RemoveFromHydroGeneratingUnits(HydroGeneratingUnit value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(HydroGeneratingUnits), value);
        }
         
        public void RemoveAllFromHydroGeneratingUnits()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(HydroGeneratingUnits));
        }
         
    }
     
    /// <summary>
    /// A water driven prime mover. Typical turbine types are: Francis, Kaplan,
    /// and Pelton.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroTurbine")]
    public partial class HydroTurbine : PrimeMover, IModelObject
    {
        public HydroTurbine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Type of turbine.
        /// </summary>
        public HydroTurbineKind turbineType
        {
            get => ObjectData.GetAttribute<HydroTurbineKind>(nameof(turbineType));
            set => ObjectData.SetAttribute<HydroTurbineKind>(nameof(turbineType), value);
        }
         
    }
     
    /// <summary>
    /// Type of turbine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroTurbineKind")]
    public enum HydroTurbineKind
    {
        /// <summary>
        /// Francis.
        /// </summary>
        francis,
        /// <summary>
        /// </summary>
        francisReversible,
        /// <summary>
        /// </summary>
        horizontalRB,
        /// <summary>
        /// Kaplan.
        /// </summary>
        kaplan,
        /// <summary>
        /// </summary>
        kaplanRB,
        /// <summary>
        /// </summary>
        kaplanRBdiagonal,
        /// <summary>
        /// </summary>
        orthogonal,
        /// <summary>
        /// Pelton.
        /// </summary>
        pelton,
    }
     
    /// <summary>
    /// A photovoltaic device or an aggregation of such devices.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhotoVoltaicUnit")]
    public partial class PhotoVoltaicUnit : PowerElectronicsUnit, IModelObject
    {
        public PhotoVoltaicUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A Plant is a collection of equipment for purposes of generation.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Plant")]
    public partial class Plant : ModelObject, IModelObject
    {
        public Plant(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float ratedP
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedP));
            set => ObjectData.SetAttribute<float>(nameof(ratedP), value);
        }
         
    }
     
    /// <summary>
    /// A connection to the AC network for energy production or consumption that
    /// uses power electronics rather than rotating machines.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerElectronicsConnection")]
    public partial class PowerElectronicsConnection : ModelObject, IModelObject
    {
        public PowerElectronicsConnection(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Maximum reactive power limit. This is the maximum (nameplate) limit for
        /// the unit.
        /// </summary>
        public float maxQ
        {
            get => ObjectData.GetAttribute<float>(nameof(maxQ));
            set => ObjectData.SetAttribute<float>(nameof(maxQ), value);
        }
         
        /// <summary>
        /// Minimum reactive power limit for the unit. This is the minimum (nameplate)
        /// limit for the unit.
        /// </summary>
        public float minQ
        {
            get => ObjectData.GetAttribute<float>(nameof(minQ));
            set => ObjectData.SetAttribute<float>(nameof(minQ), value);
        }
         
        /// <summary>
        /// </summary>
        public float ratedPowerFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedPowerFactor));
            set => ObjectData.SetAttribute<float>(nameof(ratedPowerFactor), value);
        }
         
        /// <summary>
        /// Nameplate apparent power rating for the unit.
        /// The attribute shall have a positive value.
        /// </summary>
        public float ratedS
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedS));
            set => ObjectData.SetAttribute<float>(nameof(ratedS), value);
        }
         
        /// <summary>
        /// Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
        /// for short circuit data exchange according to IEC 60909.
        /// The attribute shall be a positive value.
        /// </summary>
        public float ratedU
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedU));
            set => ObjectData.SetAttribute<float>(nameof(ratedU), value);
        }
         
        /// <summary>
        /// </summary>
        public string type
        {
            get => ObjectData.GetAttribute<string>(nameof(type));
            set => ObjectData.SetAttribute<string>(nameof(type), value);
        }
         
        /// <summary>
        /// </summary>
        public PowerElectronicsReactiveCapabilityCurve? PowerElectronicsReactiveCapabilityCurve
        {
            get => ObjectData.GetAssoc1To1<PowerElectronicsReactiveCapabilityCurve>(nameof(PowerElectronicsReactiveCapabilityCurve));
            set => ObjectData.SetAssoc1To1(nameof(PowerElectronicsReactiveCapabilityCurve), value);
        }
         
        /// <summary>
        /// An AC network connection may have several power electronics units connecting
        /// through it.
        /// </summary>
        public PowerElectronicsUnit[]? PowerElectronicsUnit
        {
            get => ObjectData.GetAssoc1ToM<PowerElectronicsUnit>(nameof(PowerElectronicsUnit));
        }
         
        public void AddToPowerElectronicsUnit(PowerElectronicsUnit value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerElectronicsUnit), value);
        }
         
        public void RemoveFromPowerElectronicsUnit(PowerElectronicsUnit value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerElectronicsUnit), value);
        }
         
        public void RemoveAllFromPowerElectronicsUnit()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerElectronicsUnit));
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#PowerElectronicsReactiveCapabilityCurve")]
    public partial class PowerElectronicsReactiveCapabilityCurve : ModelObject, IModelObject
    {
        public PowerElectronicsReactiveCapabilityCurve(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public PowerElectronicsConnection[]? PowerElectronicsConnection
        {
            get => ObjectData.GetAssoc1ToM<PowerElectronicsConnection>(nameof(PowerElectronicsConnection));
        }
         
        public void AddToPowerElectronicsConnection(PowerElectronicsConnection value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerElectronicsConnection), value);
        }
         
        public void RemoveFromPowerElectronicsConnection(PowerElectronicsConnection value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerElectronicsConnection), value);
        }
         
        public void RemoveAllFromPowerElectronicsConnection()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerElectronicsConnection));
        }
         
    }
     
    /// <summary>
    /// A generating unit or battery or aggregation that connects to the AC network
    /// using power electronics rather than rotating machines.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerElectronicsUnit")]
    public partial class PowerElectronicsUnit : ModelObject, IModelObject
    {
        public PowerElectronicsUnit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float deadband
        {
            get => ObjectData.GetAttribute<float>(nameof(deadband));
            set => ObjectData.SetAttribute<float>(nameof(deadband), value);
        }
         
        /// <summary>
        /// </summary>
        public float governorSCD
        {
            get => ObjectData.GetAttribute<float>(nameof(governorSCD));
            set => ObjectData.SetAttribute<float>(nameof(governorSCD), value);
        }
         
        /// <summary>
        /// Maximum active power limit. This is the maximum (nameplate) limit for the
        /// unit.
        /// </summary>
        public float maxP
        {
            get => ObjectData.GetAttribute<float>(nameof(maxP));
            set => ObjectData.SetAttribute<float>(nameof(maxP), value);
        }
         
        /// <summary>
        /// Minimum active power limit. This is the minimum (nameplate) limit for the
        /// unit.
        /// </summary>
        public float minP
        {
            get => ObjectData.GetAttribute<float>(nameof(minP));
            set => ObjectData.SetAttribute<float>(nameof(minP), value);
        }
         
        /// <summary>
        /// A power electronics unit has a connection to the AC network.
        /// </summary>
        public PowerElectronicsConnection? PowerElectronicsConnection
        {
            get => ObjectData.GetAssoc1To1<PowerElectronicsConnection>(nameof(PowerElectronicsConnection));
            set => ObjectData.SetAssoc1To1(nameof(PowerElectronicsConnection), value);
        }
         
    }
     
    /// <summary>
    /// A wind generating unit that connects to the AC network with power electronics
    /// rather than rotating machines or an aggregation of such units.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerElectronicsWindUnit")]
    public partial class PowerElectronicsWindUnit : PowerElectronicsUnit, IModelObject
    {
        public PowerElectronicsWindUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The machine used to develop mechanical energy used to drive a generator.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PrimeMover")]
    public partial class PrimeMover : ModelObject, IModelObject
    {
        public PrimeMover(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float ratedPower
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedPower));
            set => ObjectData.SetAttribute<float>(nameof(ratedPower), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotationSpeed
        {
            get => ObjectData.GetAttribute<float>(nameof(rotationSpeed));
            set => ObjectData.SetAttribute<float>(nameof(rotationSpeed), value);
        }
         
        /// <summary>
        /// </summary>
        public float rotorGD2
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorGD2));
            set => ObjectData.SetAttribute<float>(nameof(rotorGD2), value);
        }
         
    }
     
    /// <summary>
    /// Reactive power rating envelope versus the synchronous machine's active
    /// power, in both the generating and motoring modes. For each active power
    /// value there is a corresponding high and low reactive power limit value.
    /// Typically there will be a separate curve for each coolant condition, such
    /// as hydrogen pressure. The Y1 axis values represent reactive minimum and
    /// the Y2 axis values represent reactive maximum.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ReactiveCapabilityCurve")]
    public partial class ReactiveCapabilityCurve : ModelObject, IModelObject
    {
        public ReactiveCapabilityCurve(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Synchronous machines using this curve as default.
        /// </summary>
        public SynchronousMachine[]? InitiallyUsedBySynchronousMachines
        {
            get => ObjectData.GetAssoc1ToM<SynchronousMachine>(nameof(InitiallyUsedBySynchronousMachines));
        }
         
        public void AddToInitiallyUsedBySynchronousMachines(SynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(InitiallyUsedBySynchronousMachines), value);
        }
         
        public void RemoveFromInitiallyUsedBySynchronousMachines(SynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(InitiallyUsedBySynchronousMachines), value);
        }
         
        public void RemoveAllFromInitiallyUsedBySynchronousMachines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(InitiallyUsedBySynchronousMachines));
        }
         
        /// <summary>
        /// Synchronous machines using this curve.
        /// </summary>
        public SynchronousMachine[]? SynchronousMachines
        {
            get => ObjectData.GetAssoc1ToM<SynchronousMachine>(nameof(SynchronousMachines));
        }
         
        public void AddToSynchronousMachines(SynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(SynchronousMachines), value);
        }
         
        public void RemoveFromSynchronousMachines(SynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(SynchronousMachines), value);
        }
         
        public void RemoveAllFromSynchronousMachines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(SynchronousMachines));
        }
         
    }
     
    /// <summary>
    /// A rotating machine which may be used as a generator or motor.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RotatingMachine")]
    public partial class RotatingMachine : ModelObject, IModelObject
    {
        public RotatingMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Power factor (nameplate data). It is primarily used for short circuit data
        /// exchange according to IEC 60909. The attribute cannot be a negative value.
        /// </summary>
        public float ratedPowerFactor
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedPowerFactor));
            set => ObjectData.SetAttribute<float>(nameof(ratedPowerFactor), value);
        }
         
        /// <summary>
        /// Nameplate apparent power rating for the unit.
        /// The attribute shall have a positive value.
        /// </summary>
        public float ratedS
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedS));
            set => ObjectData.SetAttribute<float>(nameof(ratedS), value);
        }
         
        /// <summary>
        /// Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
        /// for short circuit data exchange according to IEC 60909.
        /// The attribute shall be a positive value.
        /// </summary>
        public float ratedU
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedU));
            set => ObjectData.SetAttribute<float>(nameof(ratedU), value);
        }
         
    }
     
    /// <summary>
    /// Abstract parent class for all synchronous and asynchronous machine standard
    /// models.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RotatingMachineDynamics")]
    public partial class RotatingMachineDynamics : DynamicsFunctionBlock, IModelObject
    {
        public RotatingMachineDynamics(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Inertia constant of generator or motor and mechanical load (<i>H</i>) (&gt;
        /// 0). This is the specification for the stored energy in the rotating mass
        /// when operating at rated speed. For a generator, this includes the generator
        /// plus all other elements (turbine, exciter) on the same shaft and has units
        /// of MW x s. For a motor, it includes the motor plus its mechanical load.
        /// Conventional units are PU on the generator MVA base, usually expressed
        /// as MW x s / MVA or just s. This value is used in the accelerating power
        /// reference frame for operator training simulator solutions. Typical value
        /// = 3.
        /// </summary>
        public float inertia
        {
            get => ObjectData.GetAttribute<float>(nameof(inertia));
            set => ObjectData.SetAttribute<float>(nameof(inertia), value);
        }
         
        /// <summary>
        /// Stator leakage reactance (<i>Xl</i>) (&gt;= 0). Typical value = 0,15.
        /// </summary>
        public float statorLeakageReactance
        {
            get => ObjectData.GetAttribute<float>(nameof(statorLeakageReactance));
            set => ObjectData.SetAttribute<float>(nameof(statorLeakageReactance), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#RotatingMachineInfo")]
    public partial class RotatingMachineInfo : ModelObject, IModelObject
    {
        public RotatingMachineInfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float rotorGD2
        {
            get => ObjectData.GetAttribute<float>(nameof(rotorGD2));
            set => ObjectData.SetAttribute<float>(nameof(rotorGD2), value);
        }
         
    }
     
    /// <summary>
    /// Type of rotor on physical machine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RotorKind")]
    public enum RotorKind
    {
        /// <summary>
        /// Round rotor type of synchronous machine.
        /// </summary>
        roundRotor,
        /// <summary>
        /// Salient pole type of synchronous machine.
        /// </summary>
        salientPole,
    }
     
    /// <summary>
    /// An electromechanical device that operates with shaft rotating synchronously
    /// with the network. It is a single machine operating either as a generator
    /// or synchronous condenser or pump.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachine")]
    public partial class SynchronousMachine : RotatingMachine, IModelObject
    {
        public SynchronousMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Active power consumed when in condenser mode operation.
        /// </summary>
        public float condenserP
        {
            get => ObjectData.GetAttribute<float>(nameof(condenserP));
            set => ObjectData.SetAttribute<float>(nameof(condenserP), value);
        }
         
        /// <summary>
        /// Method of cooling the machine.
        /// </summary>
        public CoolantType coolantType
        {
            get => ObjectData.GetAttribute<CoolantType>(nameof(coolantType));
            set => ObjectData.SetAttribute<CoolantType>(nameof(coolantType), value);
        }
         
        /// <summary>
        /// Indicates whether or not the generator is earthed. Used for short circuit
        /// data exchange according to IEC 60909.
        /// </summary>
        public bool earthing
        {
            get => ObjectData.GetAttribute<bool>(nameof(earthing));
            set => ObjectData.SetAttribute<bool>(nameof(earthing), value);
        }
         
        /// <summary>
        /// Generator star point earthing resistance (Re). Used for short circuit data
        /// exchange according to IEC 60909.
        /// </summary>
        public float earthingStarPointR
        {
            get => ObjectData.GetAttribute<float>(nameof(earthingStarPointR));
            set => ObjectData.SetAttribute<float>(nameof(earthingStarPointR), value);
        }
         
        /// <summary>
        /// Generator star point earthing reactance (Xe). Used for short circuit data
        /// exchange according to IEC 60909.
        /// </summary>
        public float earthingStarPointX
        {
            get => ObjectData.GetAttribute<float>(nameof(earthingStarPointX));
            set => ObjectData.SetAttribute<float>(nameof(earthingStarPointX), value);
        }
         
        /// <summary>
        /// Maximum reactive power limit. This is the maximum (nameplate) limit for
        /// the unit.
        /// </summary>
        public float maxQ
        {
            get => ObjectData.GetAttribute<float>(nameof(maxQ));
            set => ObjectData.SetAttribute<float>(nameof(maxQ), value);
        }
         
        /// <summary>
        /// Maximum voltage limit for the unit.
        /// </summary>
        public float maxU
        {
            get => ObjectData.GetAttribute<float>(nameof(maxU));
            set => ObjectData.SetAttribute<float>(nameof(maxU), value);
        }
         
        /// <summary>
        /// Minimum reactive power limit for the unit.
        /// </summary>
        public float minQ
        {
            get => ObjectData.GetAttribute<float>(nameof(minQ));
            set => ObjectData.SetAttribute<float>(nameof(minQ), value);
        }
         
        /// <summary>
        /// Minimum voltage limit for the unit.
        /// </summary>
        public float minU
        {
            get => ObjectData.GetAttribute<float>(nameof(minU));
            set => ObjectData.SetAttribute<float>(nameof(minU), value);
        }
         
        /// <summary>
        /// Current mode of operation.
        /// </summary>
        public SynchronousMachineOperatingMode operatingMode
        {
            get => ObjectData.GetAttribute<SynchronousMachineOperatingMode>(nameof(operatingMode));
            set => ObjectData.SetAttribute<SynchronousMachineOperatingMode>(nameof(operatingMode), value);
        }
         
        /// <summary>
        /// Equivalent resistance (RG) of generator. RG is considered for the calculation
        /// of all currents, except for the calculation of the peak current ip. Used
        /// for short circuit data exchange according to IEC 60909.
        /// </summary>
        public float r
        {
            get => ObjectData.GetAttribute<float>(nameof(r));
            set => ObjectData.SetAttribute<float>(nameof(r), value);
        }
         
        /// <summary>
        /// Zero sequence resistance of the synchronous machine.
        /// </summary>
        public float r0
        {
            get => ObjectData.GetAttribute<float>(nameof(r0));
            set => ObjectData.SetAttribute<float>(nameof(r0), value);
        }
         
        /// <summary>
        /// Negative sequence resistance.
        /// </summary>
        public float r2
        {
            get => ObjectData.GetAttribute<float>(nameof(r2));
            set => ObjectData.SetAttribute<float>(nameof(r2), value);
        }
         
        /// <summary>
        /// Direct-axis subtransient reactance saturated, also known as Xd"sat.
        /// </summary>
        public float satDirectSubtransX
        {
            get => ObjectData.GetAttribute<float>(nameof(satDirectSubtransX));
            set => ObjectData.SetAttribute<float>(nameof(satDirectSubtransX), value);
        }
         
        /// <summary>
        /// Modes that this synchronous machine can operate in.
        /// </summary>
        public SynchronousMachineKind type
        {
            get => ObjectData.GetAttribute<SynchronousMachineKind>(nameof(type));
            set => ObjectData.SetAttribute<SynchronousMachineKind>(nameof(type), value);
        }
         
        /// <summary>
        /// </summary>
        public float x
        {
            get => ObjectData.GetAttribute<float>(nameof(x));
            set => ObjectData.SetAttribute<float>(nameof(x), value);
        }
         
        /// <summary>
        /// Zero sequence reactance of the synchronous machine.
        /// </summary>
        public float x0
        {
            get => ObjectData.GetAttribute<float>(nameof(x0));
            set => ObjectData.SetAttribute<float>(nameof(x0), value);
        }
         
        /// <summary>
        /// Negative sequence reactance.
        /// </summary>
        public float x2
        {
            get => ObjectData.GetAttribute<float>(nameof(x2));
            set => ObjectData.SetAttribute<float>(nameof(x2), value);
        }
         
        /// <summary>
        /// </summary>
        public ExcitationSystem[]? ExcitationSystem
        {
            get => ObjectData.GetAssoc1ToM<ExcitationSystem>(nameof(ExcitationSystem));
        }
         
        public void AddToExcitationSystem(ExcitationSystem value)
        {
            ObjectData.AddAssoc1ToM(nameof(ExcitationSystem), value);
        }
         
        public void RemoveFromExcitationSystem(ExcitationSystem value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ExcitationSystem), value);
        }
         
        public void RemoveAllFromExcitationSystem()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ExcitationSystem));
        }
         
        /// <summary>
        /// The default reactive capability curve for use by a synchronous machine.
        /// </summary>
        public ReactiveCapabilityCurve? InitialReactiveCapabilityCurve
        {
            get => ObjectData.GetAssoc1To1<ReactiveCapabilityCurve>(nameof(InitialReactiveCapabilityCurve));
            set => ObjectData.SetAssoc1To1(nameof(InitialReactiveCapabilityCurve), value);
        }
         
        /// <summary>
        /// All available reactive capability curves for this synchronous machine.
        /// </summary>
        public ReactiveCapabilityCurve[]? ReactiveCapabilityCurves
        {
            get => ObjectData.GetAssoc1ToM<ReactiveCapabilityCurve>(nameof(ReactiveCapabilityCurves));
        }
         
        public void AddToReactiveCapabilityCurves(ReactiveCapabilityCurve value)
        {
            ObjectData.AddAssoc1ToM(nameof(ReactiveCapabilityCurves), value);
        }
         
        public void RemoveFromReactiveCapabilityCurves(ReactiveCapabilityCurve value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ReactiveCapabilityCurves), value);
        }
         
        public void RemoveAllFromReactiveCapabilityCurves()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ReactiveCapabilityCurves));
        }
         
        /// <summary>
        /// Synchronous machine dynamics model used to describe dynamic behaviour of
        /// this synchronous machine.
        /// </summary>
        public SynchronousMachineDynamics? SynchronousMachineDynamics
        {
            get => ObjectData.GetAssoc1To1<SynchronousMachineDynamics>(nameof(SynchronousMachineDynamics));
            set => ObjectData.SetAssoc1To1(nameof(SynchronousMachineDynamics), value);
        }
         
    }
     
    /// <summary>
    /// All synchronous machine detailed types use a subset of the same data parameters
    /// and input/output variables.
    /// The several variations differ in the following ways:
    /// - the number of equivalent windings that are included;
    /// - the way in which saturation is incorporated into the model;
    /// - whether or not subtransient saliency (<i>X''q</i> not = <i>X''d</i>)
    /// is represented.
    /// It is not necessary for each simulation tool to have separate models for
    /// each of the model types. The same model can often be used for several types
    /// by alternative logic within the model. Also, differences in saturation
    /// representation might not result in significant model performance differences
    /// so model substitutions are often acceptable.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachineDetailed")]
    public partial class SynchronousMachineDetailed : SynchronousMachineDynamics, IModelObject
    {
        public SynchronousMachineDetailed(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Synchronous machine whose behaviour is described by reference to a standard
    /// model expressed in one of the following forms:
    /// - simplified (or classical), where a group of generators or motors is not
    /// modelled in detail;
    /// - detailed, in equivalent circuit form;
    /// - detailed, in time constant reactance form; or
    /// <font color="#0f0f0f">- by definition of a user-defined model.</font>
    /// <font color="#0f0f0f">It is a common practice to represent small generators
    /// by a negative load rather than by a dynamic generator model when performing
    /// dynamics simulations. In this case, a SynchronousMachine in the static
    /// model is not represented by anything in the dynamics model, instead it
    /// is treated as an ordinary load.</font>
    /// <font color="#0f0f0f">Parameter details:</font>
    /// <ol>
    /// <li><font color="#0f0f0f">Synchronous machine parameters such as <i>Xl,
    /// Xd, Xp</i> etc. are actually used as inductances in the models,</font>
    /// but are commonly referred to as reactances since, at nominal frequency,
    /// the PU values are the same. However, some references use the symbol <i>L</i>
    /// instead of <i>X</i>.</li>
    /// </ol>
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachineDynamics")]
    public partial class SynchronousMachineDynamics : RotatingMachineDynamics, IModelObject
    {
        public SynchronousMachineDynamics(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Synchronous machine to which synchronous machine dynamics model applies.
        /// </summary>
        public SynchronousMachine? SynchronousMachine
        {
            get => ObjectData.GetAssoc1To1<SynchronousMachine>(nameof(SynchronousMachine));
            set => ObjectData.SetAssoc1To1(nameof(SynchronousMachine), value);
        }
         
    }
     
    /// <summary>
    /// Synchronous machine type.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachineKind")]
    public enum SynchronousMachineKind
    {
        /// <summary>
        /// Indicates the synchronous machine can operate as a condenser.
        /// </summary>
        condenser,
        /// <summary>
        /// Indicates the synchronous machine can operate as a generator.
        /// </summary>
        generator,
        /// <summary>
        /// Indicates the synchronous machine can operate as a generator or as a condenser.
        /// </summary>
        generatorOrCondenser,
        /// <summary>
        /// Indicates the synchronous machine can operate as a generator or as a condenser
        /// or as a motor.
        /// </summary>
        generatorOrCondenserOrMotor,
        /// <summary>
        /// Indicates the synchronous machine can operate as a generator or as a motor.
        /// </summary>
        generatorOrMotor,
        /// <summary>
        /// Indicates the synchronous machine can operate as a motor.
        /// </summary>
        motor,
        /// <summary>
        /// Indicates the synchronous machine can operate as a motor or as a condenser.
        /// </summary>
        motorOrCondenser,
    }
     
    /// <summary>
    /// Synchronous machine operating mode.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachineOperatingMode")]
    public enum SynchronousMachineOperatingMode
    {
        /// <summary>
        /// Operating as condenser.
        /// </summary>
        condenser,
        /// <summary>
        /// Operating as generator.
        /// </summary>
        generator,
        /// <summary>
        /// Operating as motor.
        /// </summary>
        motor,
    }
     
    /// <summary>
    /// Synchronous machine detailed modelling types are defined by the combination
    /// of the attributes SynchronousMachineTimeConstantReactance.modelType and
    /// SynchronousMachineTimeConstantReactance.rotorType.
    /// Parameter details:
    /// <ol>
    /// <li>The p in the time-related attribute names is a substitution for a
    /// prime in the usual parameter notation, e.g. tpdo refers to <i>T'do</i>.</li>
    /// <li>The parameters used for models expressed in time constant reactance
    /// form include:</li>
    /// </ol>
    /// - RotatingMachine.ratedS (<i>MVAbase</i>);
    /// - RotatingMachineDynamics.damping (<i>D</i>);
    /// - RotatingMachineDynamics.inertia (<i>H</i>);
    /// - RotatingMachineDynamics.saturationFactor (<i>S1</i>);
    /// - RotatingMachineDynamics.saturationFactor120 (<i>S12</i>);
    /// - RotatingMachineDynamics.statorLeakageReactance (<i>Xl</i>);
    /// - RotatingMachineDynamics.statorResistance (<i>Rs</i>);
    /// - SynchronousMachineTimeConstantReactance.ks (<i>Ks</i>);
    /// - SynchronousMachineDetailed.saturationFactorQAxis (<i>S1q</i>);
    /// - SynchronousMachineDetailed.saturationFactor120QAxis (<i>S12q</i>);
    /// - SynchronousMachineDetailed.efdBaseRatio;
    /// - SynchronousMachineDetailed.ifdBaseType;
    /// - .xDirectSync (<i>Xd</i>);
    /// - .xDirectTrans (<i>X'd</i>);
    /// - .xDirectSubtrans (<i>X''d</i>);
    /// - .xQuadSync (<i>Xq</i>);
    /// - .xQuadTrans (<i>X'q</i>);
    /// - .xQuadSubtrans (<i>X''q</i>);
    /// - .tpdo (<i>T'do</i>);
    /// - .tppdo (<i>T''do</i>);
    /// - .tpqo (<i>T'qo</i>);
    /// - .tppqo (<i>T''qo</i>);
    /// - .tc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachineTimeConstantReactance")]
    public partial class SynchronousMachineTimeConstantReactance : SynchronousMachineDetailed, IModelObject
    {
        public SynchronousMachineTimeConstantReactance(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Type of rotor on physical machine.
        /// </summary>
        public RotorKind rotorType
        {
            get => ObjectData.GetAttribute<RotorKind>(nameof(rotorType));
            set => ObjectData.SetAttribute<RotorKind>(nameof(rotorType), value);
        }
         
        /// <summary>
        /// </summary>
        public float tdo
        {
            get => ObjectData.GetAttribute<float>(nameof(tdo));
            set => ObjectData.SetAttribute<float>(nameof(tdo), value);
        }
         
        /// <summary>
        /// </summary>
        public float tpd
        {
            get => ObjectData.GetAttribute<float>(nameof(tpd));
            set => ObjectData.SetAttribute<float>(nameof(tpd), value);
        }
         
        /// <summary>
        /// Direct-axis transient rotor time constant (<i>T'do</i>) (&gt; SynchronousMachineTimeConstantReactance.tppdo).
        /// Typical value = 5.
        /// </summary>
        public float tpdo
        {
            get => ObjectData.GetAttribute<float>(nameof(tpdo));
            set => ObjectData.SetAttribute<float>(nameof(tpdo), value);
        }
         
        /// <summary>
        /// </summary>
        public float tppd
        {
            get => ObjectData.GetAttribute<float>(nameof(tppd));
            set => ObjectData.SetAttribute<float>(nameof(tppd), value);
        }
         
        /// <summary>
        /// Direct-axis subtransient rotor time constant (<i>T''do</i>) (&gt; 0). Typical
        /// value = 0,03.
        /// </summary>
        public float tppdo
        {
            get => ObjectData.GetAttribute<float>(nameof(tppdo));
            set => ObjectData.SetAttribute<float>(nameof(tppdo), value);
        }
         
        /// <summary>
        /// </summary>
        public float tppq
        {
            get => ObjectData.GetAttribute<float>(nameof(tppq));
            set => ObjectData.SetAttribute<float>(nameof(tppq), value);
        }
         
        /// <summary>
        /// Quadrature-axis subtransient rotor time constant (<i>T''qo</i>) (&gt; 0).
        /// Typical value = 0,03.
        /// </summary>
        public float tppqo
        {
            get => ObjectData.GetAttribute<float>(nameof(tppqo));
            set => ObjectData.SetAttribute<float>(nameof(tppqo), value);
        }
         
        /// <summary>
        /// Quadrature-axis transient rotor time constant (<i>T'qo</i>) (&gt; SynchronousMachineTimeConstantReactance.tppqo).
        /// Typical value = 0,5.
        /// </summary>
        public float tpqo
        {
            get => ObjectData.GetAttribute<float>(nameof(tpqo));
            set => ObjectData.SetAttribute<float>(nameof(tpqo), value);
        }
         
        /// <summary>
        /// Direct-axis subtransient reactance (unsaturated) (<i>X''d</i>) (&gt; RotatingMachineDynamics.statorLeakageReactance).
        /// Typical value = 0,2.
        /// </summary>
        public float xDirectSubtrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectSubtrans));
            set => ObjectData.SetAttribute<float>(nameof(xDirectSubtrans), value);
        }
         
        /// <summary>
        /// Direct-axis synchronous reactance (<i>Xd</i>) (&gt;= SynchronousMachineTimeConstantReactance.xDirectTrans).
        /// The quotient of a sustained value of that AC component of armature voltage
        /// that is produced by the total direct-axis flux due to direct-axis armature
        /// current and the value of the AC component of this current, the machine
        /// running at rated speed. Typical value = 1,8.
        /// </summary>
        public float xDirectSync
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectSync));
            set => ObjectData.SetAttribute<float>(nameof(xDirectSync), value);
        }
         
        /// <summary>
        /// Direct-axis transient reactance (unsaturated) (<i>X'd</i>) (&gt;= SynchronousMachineTimeConstantReactance.xDirectSubtrans).
        /// Typical value = 0,5.
        /// </summary>
        public float xDirectTrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xDirectTrans));
            set => ObjectData.SetAttribute<float>(nameof(xDirectTrans), value);
        }
         
        /// <summary>
        /// Quadrature-axis subtransient reactance (<i>X''q</i>) (&gt; RotatingMachineDynamics.statorLeakageReactance).
        /// Typical value = 0,2.
        /// </summary>
        public float xQuadSubtrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xQuadSubtrans));
            set => ObjectData.SetAttribute<float>(nameof(xQuadSubtrans), value);
        }
         
        /// <summary>
        /// Quadrature-axis synchronous reactance (<i>Xq</i>) (&gt;= SynchronousMachineTimeConstantReactance.xQuadTrans).
        /// The ratio of the component of reactive armature voltage, due to the quadrature-axis
        /// component of armature current, to this component of current, under steady
        /// state conditions and at rated frequency. Typical value = 1,6.
        /// </summary>
        public float xQuadSync
        {
            get => ObjectData.GetAttribute<float>(nameof(xQuadSync));
            set => ObjectData.SetAttribute<float>(nameof(xQuadSync), value);
        }
         
        /// <summary>
        /// Quadrature-axis transient reactance (<i>X'q</i>) (&gt;= SynchronousMachineTimeConstantReactance.xQuadSubtrans).
        /// Typical value = 0,3.
        /// </summary>
        public float xQuadTrans
        {
            get => ObjectData.GetAttribute<float>(nameof(xQuadTrans));
            set => ObjectData.SetAttribute<float>(nameof(xQuadTrans), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#SynchronousMachinelnfo")]
    public partial class SynchronousMachinelnfo : RotatingMachineInfo, IModelObject
    {
        public SynchronousMachinelnfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float asyncModeAllowedTime
        {
            get => ObjectData.GetAttribute<float>(nameof(asyncModeAllowedTime));
            set => ObjectData.SetAttribute<float>(nameof(asyncModeAllowedTime), value);
        }
         
        /// <summary>
        /// </summary>
        public float generatorGD2
        {
            get => ObjectData.GetAttribute<float>(nameof(generatorGD2));
            set => ObjectData.SetAttribute<float>(nameof(generatorGD2), value);
        }
         
        /// <summary>
        /// </summary>
        public bool isAsyncModeAdmissibility
        {
            get => ObjectData.GetAttribute<bool>(nameof(isAsyncModeAdmissibility));
            set => ObjectData.SetAttribute<bool>(nameof(isAsyncModeAdmissibility), value);
        }
         
        /// <summary>
        /// </summary>
        public float maxLoadExcCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(maxLoadExcCurrent));
            set => ObjectData.SetAttribute<float>(nameof(maxLoadExcCurrent), value);
        }
         
        /// <summary>
        /// </summary>
        public float maxLoadExcVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(maxLoadExcVoltage));
            set => ObjectData.SetAttribute<float>(nameof(maxLoadExcVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float noLoadExcCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(noLoadExcCurrent));
            set => ObjectData.SetAttribute<float>(nameof(noLoadExcCurrent), value);
        }
         
        /// <summary>
        /// </summary>
        public float noLoadExcVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(noLoadExcVoltage));
            set => ObjectData.SetAttribute<float>(nameof(noLoadExcVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float nominalRotationSpeed
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalRotationSpeed));
            set => ObjectData.SetAttribute<float>(nameof(nominalRotationSpeed), value);
        }
         
        /// <summary>
        /// </summary>
        public float ratedExcCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedExcCurrent));
            set => ObjectData.SetAttribute<float>(nameof(ratedExcCurrent), value);
        }
         
        /// <summary>
        /// </summary>
        public float ratedExcVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(ratedExcVoltage));
            set => ObjectData.SetAttribute<float>(nameof(ratedExcVoltage), value);
        }
         
        /// <summary>
        /// </summary>
        public float shortCircuitExcCurrent
        {
            get => ObjectData.GetAttribute<float>(nameof(shortCircuitExcCurrent));
            set => ObjectData.SetAttribute<float>(nameof(shortCircuitExcCurrent), value);
        }
         
    }
     
    /// <summary>
    /// A generating unit whose prime mover could be a steam turbine, combustion
    /// turbine, or diesel engine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ThermalGeneratingUnit")]
    public partial class ThermalGeneratingUnit : GeneratingUnit, IModelObject
    {
        public ThermalGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public CapacityConfiguration[]? CapacityConfiguration
        {
            get => ObjectData.GetAssoc1ToM<CapacityConfiguration>(nameof(CapacityConfiguration));
        }
         
        public void AddToCapacityConfiguration(CapacityConfiguration value)
        {
            ObjectData.AddAssoc1ToM(nameof(CapacityConfiguration), value);
        }
         
        public void RemoveFromCapacityConfiguration(CapacityConfiguration value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(CapacityConfiguration), value);
        }
         
        public void RemoveAllFromCapacityConfiguration()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(CapacityConfiguration));
        }
         
        /// <summary>
        /// A thermal generating unit may be a member of a cogeneration plant.
        /// </summary>
        public CogenerationPlant? CogenerationPlant
        {
            get => ObjectData.GetAssoc1To1<CogenerationPlant>(nameof(CogenerationPlant));
            set => ObjectData.SetAssoc1To1(nameof(CogenerationPlant), value);
        }
         
        /// <summary>
        /// A thermal generating unit may be a member of a combined cycle plant.
        /// </summary>
        public CombinedCyclePlant? CombinedCyclePlant
        {
            get => ObjectData.GetAssoc1To1<CombinedCyclePlant>(nameof(CombinedCyclePlant));
            set => ObjectData.SetAssoc1To1(nameof(CombinedCyclePlant), value);
        }
         
        /// <summary>
        /// A thermal generating unit may have one or more fossil fuels.
        /// </summary>
        public FossilFuel[]? FossilFuels
        {
            get => ObjectData.GetAssoc1ToM<FossilFuel>(nameof(FossilFuels));
        }
         
        public void AddToFossilFuels(FossilFuel value)
        {
            ObjectData.AddAssoc1ToM(nameof(FossilFuels), value);
        }
         
        public void RemoveFromFossilFuels(FossilFuel value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(FossilFuels), value);
        }
         
        public void RemoveAllFromFossilFuels()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(FossilFuels));
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#TorqueSpeedCurve")]
    public partial class TorqueSpeedCurve : ModelObject, IModelObject
    {
        public TorqueSpeedCurve(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public AsynchronousMachine[]? AsynchronousMachine
        {
            get => ObjectData.GetAssoc1ToM<AsynchronousMachine>(nameof(AsynchronousMachine));
        }
         
        public void AddToAsynchronousMachine(AsynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(AsynchronousMachine), value);
        }
         
        public void RemoveFromAsynchronousMachine(AsynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AsynchronousMachine), value);
        }
         
        public void RemoveAllFromAsynchronousMachine()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AsynchronousMachine));
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#TurbineRegulatinglnfo")]
    public partial class TurbineRegulatinglnfo : ModelObject, IModelObject
    {
        public TurbineRegulatinglnfo(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public float fastValvingControl
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControl));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControl), value);
        }
         
        /// <summary>
        /// </summary>
        public float fastValvingControlBlockTime
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControlBlockTime));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControlBlockTime), value);
        }
         
        /// <summary>
        /// </summary>
        public float fastValvingControlDelay
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControlDelay));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControlDelay), value);
        }
         
        /// <summary>
        /// </summary>
        public float fastValvingControlRampRate
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControlRampRate));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControlRampRate), value);
        }
         
        /// <summary>
        /// </summary>
        public float fastValvingControlRate
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControlRate));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControlRate), value);
        }
         
        /// <summary>
        /// </summary>
        public float fastValvingControlRestoreTime
        {
            get => ObjectData.GetAttribute<float>(nameof(fastValvingControlRestoreTime));
            set => ObjectData.SetAttribute<float>(nameof(fastValvingControlRestoreTime), value);
        }
         
        /// <summary>
        /// </summary>
        public float freqControlDeadband
        {
            get => ObjectData.GetAttribute<float>(nameof(freqControlDeadband));
            set => ObjectData.SetAttribute<float>(nameof(freqControlDeadband), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyCorrectorDeadband
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyCorrectorDeadband));
            set => ObjectData.SetAttribute<float>(nameof(frequencyCorrectorDeadband), value);
        }
         
        /// <summary>
        /// </summary>
        public float frequencyCorrectorSCD
        {
            get => ObjectData.GetAttribute<float>(nameof(frequencyCorrectorSCD));
            set => ObjectData.SetAttribute<float>(nameof(frequencyCorrectorSCD), value);
        }
         
        /// <summary>
        /// </summary>
        public float sustainedFastValvingControlRampRate
        {
            get => ObjectData.GetAttribute<float>(nameof(sustainedFastValvingControlRampRate));
            set => ObjectData.SetAttribute<float>(nameof(sustainedFastValvingControlRampRate), value);
        }
         
        /// <summary>
        /// </summary>
        public float sustainedFastValvingControlRate
        {
            get => ObjectData.GetAttribute<float>(nameof(sustainedFastValvingControlRate));
            set => ObjectData.SetAttribute<float>(nameof(sustainedFastValvingControlRate), value);
        }
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#WindTurbine")]
    public partial class WindTurbine : PrimeMover, IModelObject
    {
        public WindTurbine(DataFacade objectData) : base(objectData) {}
         
    }
     
}
